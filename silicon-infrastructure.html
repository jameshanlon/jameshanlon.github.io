<!DOCTYPE html>
<!-- Make light mode the default for articles since this works better with
    images with a white background and code highlighting. -->
<html lang="en" data-bs-theme=light>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="James W. Hanlon">
  <title>SiliconÂ infrastructure</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./theme/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./theme/images/favicon-16x16.png">
  <!-- Default Pygments style -->
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" id="pygments-style"/>
  <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
  <link href="https://jameswhanlon.com/reeds/atom.xml"
        type="application/atom+xml" rel="alternate"
        title="James W. Hanlon Atom Feed" />
  <link href="https://jameswhanlon.com/reeds/rss.xml"
        type="application/rss+xml" rel="alternate"
        title="James W. Hanlon RSS Feed" />
  <!-- MathJax -->
  <script>
  MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
              svg: { fontCache: 'global' } };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>
  <script src="./theme/js/bundle.js"></script>
  <script data-goatcounter="https://jameswhanlon.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</head>
<body>
  <header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0 text-uppercase">
          <li class="nav-item">
              <a class="nav-link" href="/index.html">notes</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/projects.html">projects</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive.html">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about.html">about</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/links.html">links</a>
          </li>
        </ul>
        <a class="navbar-brand" href="#">James W. Hanlon</a>
        <button class="btn btn-secondary" type="button" onclick="toggleMode(this)">
          <!-- Initial button state -->
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </div>
  </nav>
  </header>

  <main class="flex-shrink-0">
  <div class="container">
  <h1>
    Silicon&nbsp;infrastructure
  </h1>
  <div class="lead">
    <time class="published" datetime="2023-08-02T00:00:00+02:00">
      02 Aug 2023
    </time><br>
      <span class="article-tag small"><a href="/tag/computing.html">computing</a></span>
      <span class="article-tag small"><a href="/tag/microelectronics.html">microelectronics</a></span>
      <span class="article-tag small"><a href="/tag/verilog.html">verilog</a></span>
  </div>
  <div class="article-body">
    <p>Modern chip design differs to conventional software engineering in three
fundamental aspects that require a somewhat different approach to project&nbsp;development:</p>
<ul>
<li>
<p><strong>Transformations and representations</strong>. The creation of a chip design from
  a source-level representation through to a final <span class="caps">GDSII</span> description of the
  layout involves many stages of incremental transformations of the circuit and
  layout, and then incremental assembly of components into various subsystems
  before finally the entire chip. At various stages through this process, checks
  are performed on the design typically using simplified representations to
  reduce complexity and make run times&nbsp;practical.</p>
</li>
<li>
<p><strong>Tooling</strong>. Compared to software tooling, standard chip-design tooling
  (known in the industry as <em>electronic design automation</em>) :
    (1) is almost all proprietary and used under license, meaning that interactive
    and automated use is limited and at odds with a continuous-integration model
    of development;
    (2) can have long run times (upwards of 12 hours for a job are not uncommon) and produce
    vast quantities of data, making it very unattractive to rerun something
    unless absolutely necessary; and
    (3) can be non-deterministic in that rerunning a job with the same set of inputs
    produces a different&nbsp;output.</p>
</li>
<li>
<p><strong>Tape out</strong>. When a design is released for manufacture (known in the
  industry as a <em>tape out</em>), there are typically high non-recoverable expenses associated
  with setting up the processes and a long lead time in receiving a (hopefully)
  working device. There are two implications of this situation:
    (1) chip tape outs precludes incremental releases, for example to fix trivial bugs, and
    therefore means that the confidence in the correct functionality of the
    design must be very high;
    (2) post tape out, the design source code is effectively frozen forever more for
    the purposes of debug and&nbsp;analysis.</p>
</li>
</ul>
<p>Despite these differences, many of the techniques and tools from software
engineering can readily be applied to chip development, particularly to manage
complexity and maintain high standards of code quality, testing and
integration. This note lays out some thoughts and opinions on the components
and structure of a software infrastructure to build&nbsp;chips.</p>
<h3>Table of&nbsp;contents</h3>
<ol>
<li><a href="#aims">Aims</a></li>
<li><a href="#principles">Guiding&nbsp;principles</a></li>
<li><a href="#flows">Flows</a></li>
<li><a href="#model">Model</a></li>
<li><a href="#details">Details</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#acknowledgements">Acknowledgments</a></li>
<li><a href="#related-projects">Related&nbsp;projects</a></li>
</ol>
<h2>Aims <a name="aims" class="anchor"></a></h2>
<p>The overall objective of a silicon infrastructure is to <strong>support the
development of a verified chip design from <span class="caps">RTL</span> to <span class="caps">GDSII</span></strong>. To make this more
specific, I also define the following capabilities that should be supported as
an overall philosophy of the approach that is explored in this&nbsp;note:</p>
<ul>
<li>
<p>To <strong>rerun everything from scratch</strong>, requiring full
  automation of an the end-to-end flow. This is intended to: (1) distribute the
  task of integrating components of a design across a team, thereby revealing
  issues at as earlier stage in the project as possible to avoid disruptive
  changes towards the end; (2) enable faster design iteration; and (3)
  provide traceability of results (a foundation for the next&nbsp;aim).</p>
</li>
<li>
<p>Provide a <strong>full audit trail</strong> such that a release of a design for tape out
  has data and a set of reports, logs, coverage metrics, documentation and
  signoffs that are traceable back to the original <span class="caps">RTL</span> source files. This is
  important for building confidence to tape out, as well as providing information
  for future work on a completed&nbsp;design.</p>
</li>
<li>
<p>Support <strong>multiple chips and frozen designs</strong> to keep previous generations
  alive for debug of silicon issues and/or as a basis for a incremental tape out
  (known as a <em>respin</em>), and to allow multiple designs to be built&nbsp;concurrently.</p>
</li>
</ul>
<h2>Guiding principles <a name="principles" class="anchor"></a></h2>
<p>I think it is useful to underpin the aims, implementation and operation of a
chip-design infrastructure are a set of guiding principles for the project team
to employ when design decisions need to be made.  These principles are formed
from my own experience and through conversations with others. I am sure that
alternative foundations can be constructed and argued&nbsp;for.</p>
<ol>
<li>
<p><strong>Simple and explicit</strong>. Build a complex system using simple, well-defined
components composed and controlled using explicit mechanisms. Conversely, avoid
easy-to-use high-level interfaces that hide important behaviours. This borrows
from the <a href="https://peps.python.org/pep-0020/">Zen of Python</a>: <em>explicit is better
than implicit and simple is better than complex</em>. Examples include avoiding the
use of global variables, preferring flat rather than nested, preferring
decisions to be made explicitly and avoiding special cases that break the&nbsp;rules.</p>
</li>
<li>
<p><strong>Use a monorepository</strong>. One repository should contain all the code for all
active projects. This enhances all team members&#8217; ability to integrate their
changes across projects and removes barriers to interaction between different
teams and/or areas of the design. Other <a href="https://en.wikipedia.org/wiki/Monorepo">general
benefits</a> of a monorepository are the
ability to reuse code and do large-scale refactoring. A great deal of care must
be taken to manage dependencies between projects/components within a
monorepository. Without such care, unexpected interdependencies can cause
unexpected breakages, prevent refactoring and preclude focused testing. In
general: isolate components by restricting them to only be able to access their
listed dependencies; divide components by function and abstraction level (eg
don&#8217;t group by language or technology); and use a standard structure for each
component (such&nbsp;as <code>lib</code>, <code>sources</code>, <code>README</code> etc).</p>
</li>
<li>
<p><strong>Embrace open source</strong>. To save on effort, leverage freely-available tools
and libraries wherever possible in the infrastructure, rather than implementing
custom versions. Where open source is used, contributions back upstream benefit
the community and help to align the project with the way it is being deployed.
This particularly applies to open source in the <span class="caps">ASIC</span>/<span class="caps">FPGA</span> domain, where
<a href="https://github.com/aolofsson/awesome-opensource-hardware">open-source software</a> is unencumbered by licensing restrictions. Often
chip projects will be on tight schedules, so careful judgment of the
effort-benefit tradeoff must be&nbsp;made.</p>
</li>
<li>
<p><strong>Performance is important</strong>. With the ability to rerun everything from
scratch coupled with a multi-chip and monorepository approach, the compute
demands can scale quickly so it is crucial that the infrastructure is
performant. This can easily become a problem with codebases make extensive use
of a scripting language such as Python.  Mitigations include writing (or
rewriting) parts in a lower-level language such as C++, and setting things up in
such a way that this Python and C++ components can interoperate cleanly (eg
well-defined boundaries and&nbsp;dependencies).</p>
</li>
</ol>
<h2>Flows <a name="flows" class="anchor"></a></h2>
<p>This section outlines the high-level <em>flows</em> that a chip-design infrastructure
needs to support, meaning (typically) a sequence of steps to achieve some
<em>task</em>. This is not meant to be exhaustive, but characteristic of the types of
tasks that need to be performed. Flows can be just a single step or can be
composed together to create different flows, but always have defined inputs and
outputs. I use the term <em>job</em> to mean a particular program or script that is
executed, typically corresponding to a&nbsp;step.</p>
<ul>
<li><strong>Design representation</strong>. To read a design into a tool, the design must have
  a complete representation including tool-agnostic configuration, macro
  defines, library files and <span class="caps">RTL</span> sources. Often, <span class="caps">RTL</span> code will need to be
  generated programatically using templates or other types of code generators. It
  is also typical that a design will be implemented in a hierarchical fashion, so
  a configuration step must gather together the required modules and package it
  into a single representation. As an example, the open-source <a href="https://github.com/pulp-platform/bender">Bender</a>
  dependency management tool provides very similar&nbsp;functionality.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/design-representation.png" alt="No alt text">
</div>

<ul>
<li><strong>Verification representation</strong>. For the purposes of simulation and
  analysis, a verification representation is a variation of a design
  representation, adding configuration and macro defines, source files for a test
  bench, monitors, assertions etc, and possibly substituting parts of the design
  for fast models or block boxes. These verification components will likely live
  with the corresponding parts of the design and be collected together as they
  were for the design representation during a configuration&nbsp;step.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/verif-representation.png" alt="No alt text">
</div>

<ul>
<li><strong>Lint checking</strong>. <span class="caps">RTL</span> source code can be checked for basic coding issues
  (referred to as <em>linting</em>) by passing it through tools that perform various
  built-in or custom checks. The input to this task is the specification of a
  design and the output is a list of warnings to be reviewed. Example open-source
  tools that can be used for linting are <a href="https://verilator.org/guide/latest">Verilator</a>,
  <a href="https://chipsalliance.github.io/verible">Verible</a>, <a href="https://sv-lang.com">Slang</a>, <a href="https://github.com/dalance/svlint">svlint</a> and <a href="https://yosyshq.net/yosys">Yosys</a>.</li>
</ul>
<div class="text-center">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/lint-check.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/lint-check_1000x1000.png" alt="No alt text">
  </a>
</div>

<ul>
<li><strong><span class="caps">CDC</span> and <span class="caps">RDC</span> checking</strong>. Clock- and reset-domain crossings can be checked
  automatically with tools that analyse a design, typically with a set of
  annotations and constraints. The output will be warning messages from the
  checker that need to be&nbsp;investigated.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/cdc-rdc-check.png" alt="No alt text">
</div>

<ul>
<li><strong>Simulation testbench</strong>. A simulation test bench requires a representation
  of the design, a verification environment and test stimulus. Test stimulus is
  often randomly generated. Coverage (structural or functional) can be collected
  during simulation and when many test instances are run for a particular test
  generator or over a larger regression of different test generators, coverage
  may need to be merged then reported on. Simulation is typically performed on an
  <span class="caps">RTL</span> representation, but can also be performed on gate-level netlists and with
  and without delay&nbsp;annotations.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/simulation-flow.png" alt="No alt text">
</div>

<ul>
<li><strong>Formal property test bench</strong>. Analysing and proving formal properties of a
  design is a complementary technique to standard functional coverage. Inputs
  to this are a verification representation of the design and a set of
  assumptions and properties to be&nbsp;checked.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/formal-property-check.png" alt="No alt text">
</div>

<ul>
<li><strong>Formal equivalence check</strong>. As a design is incrementally transformed
  between <span class="caps">RTL</span> and <span class="caps">GDSII</span>, it is essential to perform equivalence checks to
  prove that each transformation maintains the functional behaviour of the
  design. Inputs to an equivalence check are two representations, typically
  called a <em>reference</em> that is the baseline and an <em>implementation</em> to&nbsp;check.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/equivalence-flow.png" alt="No alt text">
</div>

<ul>
<li><strong>Physical build</strong>. All flows up to this point have mainly operated on <span class="caps">RTL</span>
  representations of a design. A physical build flow starts off by
  transforming <span class="caps">RTL</span> into gates using a synthesis tool, then progressively
  transforming the design into a set of two-dimensional layers. Following synthesis
  are: scan insertion for <span class="caps">DFT</span>, floorplanning (placing ports and macros),
  placement (placing cells), clock tree synthesis, routing (establishing all
  required connections using the available routing layers, finishing and
  checking. See <a href="https://github.com/The-OpenROAD-Project/OpenROAD">OpenROAD</a> for an example open source physical build&nbsp;flow.</li>
</ul>
<div class="text-center">
  <img class="figure-img img-fluid" src="https://jwh.ams3.digitaloceanspaces.com/homepage/silicon-infra/phys-build-flow.png" alt="No alt text">
</div>

<blockquote>
<p><strong>A note on <span class="caps">DFT</span></strong>. A central aspect of any chip design is the <span class="caps">DFT</span> (device
test) strategy. Testability is achieved by adding logic in the form of
<em>instruments</em> and <em>connectivity</em> to make the the existing logic
<em>controllable</em> and <em>observable</em>. The means by which this is done and the
point in the development process is heavily dependent on the design and the
tooling used. Typically, <span class="caps">DFT</span> logic is inserted using automated tools during
the physical build but increasingly it is being added in <span class="caps">RTL</span> also using
automated tooling - either way adding additional transformation steps to the
front- or back-end&nbsp;flows.</p>
<p><strong>A note on physical builds</strong>. There are two unique aspects of physical
builds that present challenges for the infrastructure presented in this note.
The first is that physical <span class="caps">EDA</span> tools do not always produce the same output
given the same inputs due to the nature of the optimisation algorithms they
use. The second is that close to the closure of a design component, manual
interventions will be made to address localised issues in the design. The
combination of these issues mean that it is not possible to rerun physical
builds from scratch and achieve satisfactory results. Therefore, a silicon
infrastructure must be able to support frozen data from particular flow&nbsp;stages.</p>
</blockquote>
<h2>Model <a name="model" class="anchor"></a></h2>
<p>A model for a silicon infrastructure that captures the use cases described is a
hierarchical collection of <em>tasks</em> that consume inputs and produce outputs. A
task can be dependent on another task by consuming that task&#8217;s output and
tasks can be composed together in this way into <em>flows</em>. The set of tasks
implementing a flow form an acyclic directed graph (<span class="caps">DAG</span>) with nodes representing
fixed inputs or jobs and edges corresponding to dependencies. The structure of
this graph is determined statically (ie without any dependence on runtime
data). Execution proceeds by running tasks whose inputs are ready and letting
the task run to completion before marking its outputs as available to trigger
the execution of more tasks or the termination of the&nbsp;flow.</p>
<p>A <em>task</em> is defined&nbsp;by:</p>
<ul>
<li>A set of&nbsp;inputs.</li>
<li>A set of&nbsp;outputs.</li>
<li>A set of configuration&nbsp;values.</li>
<li>A set of resource requirements (time, memory,&nbsp;cores).</li>
<li>An <em>action</em> that that operates only on the inputs and must produce all the
  of the outputs, typically achieved by executing a script or separate&nbsp;tool.</li>
<li>If a task attempts to access an input that is not specified, then an error is&nbsp;raised.</li>
</ul>
<p>A <em>flow</em> is a hierarchical task and defined&nbsp;by:</p>
<ul>
<li>A set of&nbsp;inputs.</li>
<li>A set of&nbsp;outputs.</li>
<li>A set of configuration&nbsp;values.</li>
<li>A set of resource&nbsp;requirements.</li>
<li>A <em>action</em> consisting of executing one or more tasks according to their
  dependencies. Inputs and outputs of the flow must be connected to the sub
  tasks and similarly for dependencies between sub&nbsp;tasks.</li>
<li>Tasks can be specified using <em>replication</em> with static bounds
  to create arrays, and <em>conditionality</em> to include or exclude tasks dependent on
  configuration&nbsp;values.</li>
</ul>
<p>Configuration values are used to control the behaviour of a flow or task.
A flow can propagate configuration into its sub tasks, but it must do so
explicitly. Configuration values can be set on the command line. Example use of
configuration options is to control features like debug flags, substitution
of components of the design for simulation, or the inclusion of
tests to run in a&nbsp;regression.</p>
<p>There are a number of similar programming models that support scalable
pipelined data processing. In the field of genomics, the <a href="https://openwdl.org">Workflow Description
Language</a> (<span class="caps">WDL</span>) and <a href="https://www.commonwl.org">Common Workflow Language</a> (<span class="caps">CWL</span>) are open
programming language specifications. Example implementations of <span class="caps">WDL</span> are
<a href="https://github.com/chanzuckerberg/miniwdl">MiniWDL</a> and <a href="https://cromwell.readthedocs.io">Cromwell</a>, and of <span class="caps">CWL</span> are <a href="https://github.com/common-workflow-language/cwltool">cwltool</a>
and <a href="http://toil.ucsc-cgl.org">Toil</a>. A <a href="https://www.nextflow.io">Nextflow</a> offers comparable features but is
based on a domain-specific language implemented in Groovy. This
<a href="https://www.nature.com/articles/s41598-021-99288-8">paper</a> offers a good comparison of <span class="caps">WDL</span>, <span class="caps">CWL</span> and Nextflow. Also
worth mentioning are <a href="https://snakemake.github.io">Snakemake</a>, <a href="https://airflow.apache.org">Apache Airflow</a>, <a href="https://beam.apache.org">Apache
Beam</a>, <a href="https://github.com/spotify/luigi">Luigi</a> and <a href="https://flyte.org">Flyte</a>. I&#8217;m still investigating the
suitability of these tools for Silicon design&nbsp;workloads.</p>
<h2>Implementation details <a name="details" class="anchor"></a></h2>
<p>This section records some important details to consider when implementing a silicon
flow, as well as some nice-to-have&nbsp;features.</p>
<ul>
<li>
<p><strong>Environment</strong>. A controlled environment execution environment with specific
  tool versions for reproducability and legacy support. Container technology
  supports this requirement very will with implementations such as
  <a href="https://apptainer.org">Singularity/Apptainer</a>. A lighter-weight solution is
  <a href="https://github.com/enfabrica/enkit/tree/master/faketree">faketree</a> for managing filesystem layout in a dynamic way to meet
  the constraints of <span class="caps">EDA</span>&nbsp;tools.</p>
</li>
<li>
<p><strong>Access to compute</strong>. Dispatching of jobs to compute resources such as a
  compute cluster requires interaction with a queuing system such as
  <a href="https://slurm.schedmd.com">Slurm</a>.</p>
</li>
<li>
<p><strong>Logging</strong>. Extensive logging of job statuses is important for a
  compute-intensive workload. Straightforward access to these logs for
  inspection during and after the run should be provided, likely through a
  web-based&nbsp;dashboard.</p>
</li>
<li>
<p><strong>Fault tolerance</strong>. Flows should be robust to failures. When an task failure
  does occur, the correct statuses should be propagated up any hierarchy of
  tasks to provides visibility of the issue. The logging infrastructure should
  record any progress that was made, providing a starting point for debug or to
  restart the task. It should be straightforward to rerun part of a job that has
  failed in a reproducible&nbsp;way.</p>
</li>
<li>
<p><strong>Storage</strong>. The use of a shared filesystem such as <span class="caps">NFS</span> is typical in silicon
  <span class="caps">EDA</span> flows, however it creates a single point of failure and has limited
  scalability. An alternative shared storage system is object storage such as
  <a href="https://min.io">MinIO</a>.</p>
</li>
<li>
<p><strong>Releasing</strong>. It should be simple to release data from the repository into
  immutable storage that can then be referenced as a&nbsp;dependency.</p>
</li>
<li>
<p><strong>Periodic jobs</strong>. A mechanism for running periodic jobs is required to
  implement a continuous-integration (<span class="caps">CI</span>) and/or continuous-delivery (<span class="caps">CD</span>).
  <a href="https://www.jenkins.io">Jenkins</a>, <a href="https://github.com/features/actions">GitHub Actions</a> or <a href="https://docs.gitlab.com/ee/ci">GitLab <span class="caps">CI</span>/<span class="caps">CD</span></a>
  are all directly applicable&nbsp;here.</p>
</li>
</ul>
<h2>Summary <a name="summary" class="anchor"></a></h2>
<p>This note outlines the principles and requirements for a modern software
infrastructure to build chips. This is very different to conventional software
engineering due to fundamental differences in processes, and is likely to be
quite different from the typical methodologies used in conventional silicon
design. Based on some simple use cases, a model is proposed that abstracts the
details of resource allocation and data movement by providing tasks with inputs
and outputs as primitives. Surprisingly, there already exist a family of tools
from data science that employ a very similar&nbsp;model.</p>
<h2>Acknowledgments <a name="acknowledgements" class="anchor"></a></h2>
<p>The motivation for writing this note came from recent discussions on building a
from-scratch silicon infrastructure with <a href="http://www.jpallister.com">James Pallister</a> and <a href="https://intuity.io">Peter
Birch</a>. This note is a synthesis of ideas from those&nbsp;conversations.</p>
<h2>Related projects <a name="related-projects" class="anchor"></a></h2>
<ul>
<li><a href="https://gator.intuity.io">Gator</a>, a framework for running a hierarchy of
  jobs and aggregating logs, metrics, resource utilisation, and&nbsp;artefacts.</li>
<li><a href="https://github.com/blockwork-eda/blockwork">Blockwork</a>, is a build system and
  orchestrator for silicon&nbsp;design.</li>
<li><a href="https://blu-blade.readthedocs.io">Blade</a> is a tool for autogenerating
  modules, interconnects and register definitions from an <span class="caps">YAML</span>&nbsp;schema.</li>
<li><a href="https://github.com/siliconcompiler/siliconcompiler">Siliconcompiler</a> is a modular
  build system for silicon&nbsp;hardware.</li>
<li>Berkeley <a href="https://github.com/ucb-bar/chipyard">Chipyard</a> is an agile framework
  for hardware design, using Chisel for <span class="caps">RTL</span>&nbsp;specification.</li>
<li>Berkeley <a href="https://github.com/ucb-bar/hammer">Hammer</a> is a physical design&nbsp;framework.</li>
<li>Pulp Platform <a href="https://github.com/pulp-platform/bender">Bender</a> is a dependency
  management tool for hardware design&nbsp;projects.</li>
<li><a href="http://dungspreader.blogspot.com/">Rich Porter&#8217;s series on digital verification</a>
  and <a href="https://github.com/rporter/verilog_integration">source code</a> for the&nbsp;project.</li>
<li><a href="https://medium.com/enfabrica/melding-hardware-and-software-a-story-in-the-making-bcce28b821a8">Melding hardware and software: a story in the making</a>,
  a position piece by Enfabrica on their approach to <span class="caps">ASIC</span>&nbsp;design.</li>
</ul>
  </div>
  <div class="article-footer">
    <p>Please get in touch (mail @ this domain) with any
    comments, corrections or suggestions.</p>
  </div>
  </div>
  </main>

  <hr>
  <footer class="text-muted">
    <div class="container">
      <div class="small">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          <img alt="Creative Commons Licence" style="border-width:0"
               src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
        </a>
        <br>
        Unless otherwise noted, all content is freely available under a
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          Creative Commons Attribution 4.0 International License</a>.<br>
        The views expressed on this website are the authorâs personal views and should not be
        attributed to any other person, including that of their employer.<br>
        <br>
        Subscribe: <a href="https://jameswhanlon.com/reeds/atom.xml">Atom</a> /
        <a href="https://jameswhanlon.com/reeds/rss.xml">RSS</a>
      </div>
    </div>
  </footer>
  <script>
    function toggleMode(x) {
      // Toggle the colour mode in Bootstrap.
      if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
        document.documentElement.setAttribute('data-bs-theme','light')
      }
      else {
        document.documentElement.setAttribute('data-bs-theme','dark')
      }
      // Toggle the light/dark icon.
      x.firstElementChild.classList.toggle('bi-brightness-high-fill');
      x.firstElementChild.classList.toggle('bi-moon-fill');
      // Toggle the Pygments style.
      var elem = document.getElementById('pygments-style');
      if (elem.getAttribute('href') == './theme/css/pygments-dark.css') {
        elem.setAttribute('href', './theme/css/pygments.css');
      } else {
        elem.setAttribute('href', './theme/css/pygments-dark.css');
      }
    }
  </script>
</body>
</html>