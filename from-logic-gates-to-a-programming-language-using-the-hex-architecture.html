<!DOCTYPE html>
<!-- Make light mode the default for articles since this works better with
    images with a white background and code highlighting. -->
<html lang="en" data-bs-theme=light>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="James W. Hanlon">
  <title>From logic gates to a programming language using the HexÂ architecture</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./theme/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./theme/images/favicon-16x16.png">
  <!-- Default Pygments style -->
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" id="pygments-style"/>
  <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
  <link href="https://jameswhanlon.com/reeds/atom.xml"
        type="application/atom+xml" rel="alternate"
        title="James W. Hanlon Atom Feed" />
  <link href="https://jameswhanlon.com/reeds/rss.xml"
        type="application/rss+xml" rel="alternate"
        title="James W. Hanlon RSS Feed" />
  <!-- MathJax -->
  <script>
  MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
              svg: { fontCache: 'global' } };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>
  <script src="./theme/js/bundle.js"></script>
  <script data-goatcounter="https://jameswhanlon.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</head>
<body>
  <header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0 text-uppercase">
          <li class="nav-item">
              <a class="nav-link" href="/index.html">notes</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/projects.html">projects</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive.html">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about.html">about</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/links.html">links</a>
          </li>
        </ul>
        <a class="navbar-brand" href="#">James W. Hanlon</a>
        <button class="btn btn-secondary" type="button" onclick="toggleMode(this)">
          <!-- Initial button state -->
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </div>
  </nav>
  </header>

  <main class="flex-shrink-0">
  <div class="container">
  <h1>
    From logic gates to a programming language using the Hex&nbsp;architecture
  </h1>
  <div class="lead">
    <time class="published" datetime="2022-11-18T00:00:00+01:00">
      18 Nov 2022
    </time><br>
      <span class="article-tag small"><a href="/tag/computing.html">computing</a></span>
      <span class="article-tag small"><a href="/tag/computer-architecture.html">computer-architecture</a></span>
      <span class="article-tag small"><a href="/tag/microelectronics.html">microelectronics</a></span>
  </div>
  <div class="article-body">
    <p>This note walks through a hardware implementation of a simple processor and
complete compiler for a programming language targeted at it. The processor
architecture is designed to as simple as possible but provide a sensible target
for the compilation of complex programs using simple strategies. The
implementation of the processor and its supporting tooling is small and self
contained so to be understandable and easily extendable. Besides being an
interesting side project, my motivation was to create a complete example as a
point of reference to explain how programming languages work and correspond to
the underlying hardware of a computer processor, or to provide a useful
reference for compilers and simulators, a starting point for another project or
just a curiosity in&nbsp;itself.</p>
<p>First, to provide some background. The project is based on the Hex processor
architecture that was designed by <a href="http://people.cs.bris.ac.uk/~dave">David
May</a> as a vehicle for teaching about how
computers work at the University of Bristol, whilst being flexible enough to
execute substantial programs and easily extensible. David provided a simulator
written in C and a bootstrapping compiler written in an accompanying simple
imperative programming language called X. The design of Hex draws on the <a href="https://en.wikipedia.org/wiki/Transputer">Transputer
architecture</a> and the earlier <a href="http://people.cs.bris.ac.uk/~dave/S42ISA.pdf">Simple
42</a>, particularly with the use of
short instruction encodings, a prefixing mechanism for creating larger immediates
and A, B and C registers for expression evaluation. These kind of architectural
features made the silicon implementation of the Simple 42 and Transputers small
enough to fit on a single chip in the technology of the day. X draws on the
basic sequential features of the <a href="https://en.wikipedia.org/wiki/Occam_(programming_language)">occam programming
language</a> but it
not dissimilar to a small subset of C, for example. I include some more
historical details <a href="#a-historical-note">at the end</a>.</p>
<p>In my <a href="https://github.com/jameshanlon/hex-processor">implementation</a>, I have
created a simple C++ toolchain with a simulator, Hex assembler and X language
compiler, and a Verilog implementation of Hex. Before describing them, the
next two sections introduce Hex and&nbsp;X.</p>
<h3>Table of&nbsp;contents</h3>
<ol>
<li><a href="#the-hex-architecture">The Hex&nbsp;architecture</a></li>
<li><a href="#the-x-language">The X&nbsp;language</a></li>
<li><a href="#hex-processor-integrated-circuit">Hex processor integrated&nbsp;circuit</a></li>
<li><a href="#hex-tooling">Hex&nbsp;tooling</a></li>
<li><a href="#a-historical-note">A historical&nbsp;note</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#similar-projects">Similar&nbsp;projects</a></li>
<li><a href="#further-reading">Further&nbsp;reading</a></li>
</ol>
<h2>The Hex architecture <a name="the-hex-architecture" class="anchor"></a></h2>
<p>The Hex architecture is described in detail in <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/hexb.pdf">a separate
<span class="caps">PDF</span></a>, but I will give a brief summary here
and focus on several important aspects for reference. Hex has four registers:
program&nbsp;counter <code>pc</code>, operand&nbsp;register <code>oreg</code> and the A and B&nbsp;registers
<code>areg</code> and <code>breg</code> used for expression evaluation. The architecture is
agnostic of a particular word size, but it has to be a minimum of a byte and
multiples of a byte. In the included implementation the word size is 4 bytes.
Hex has sixteen instructions (hence its name!) that are summarised in the
following table. Each instruction has a 4-bit opcode and a 4-bit immediate. The
immediate value can be extended using the prefix instructions to form a wider
value in&nbsp;the <code>oreg</code>, adding four bits per instruction. Operations beyond the
16 available encodings are made accessible by&nbsp;the <code>OPR</code> instruction that
encodes the operation type with its immediate. The instructions are grouped
into memory access with absolute or relative addressing modes, loading of
constants, branching, inter-register operations and supervisor&nbsp;calls.</p>
<table class="table table-striped table-sm">
<thead>
  <th scope="col">Opcode</th>
  <th scope="col">Behaviour</th>
  <th scope="col">Description</th>
</thead>
<tbody>
<tr>
  <td><code>LDAM</code></td>
  <td><code>areg := mem[oreg]</code></td>
  <td>Load from memory with an absolute address into areg</td>
</tr>
<tr>
  <td><code>LDBM</code></td>
  <td><code>breg := mem[oreg]</code></td>
  <td>Load from memory with an absolute address into breg</td>
</tr>
<tr>
  <td><code>STAM</code></td>
  <td><code>mem[oreg] := areg</code></td>
  <td>Store to absolute address from areg</td>
</tr>
<tr>
  <td><code>LDAC</code></td>
  <td><code>areg := oreg</code></td>
  <td>Load constant into areg</td>
</tr>
<tr>
  <td><code>LDBC</code></td>
  <td><code>breg := oreg</code></td>
  <td>Load constant into breg</td>
</tr>
<tr>
  <td><code>LDAP</code></td>
  <td><code>areg := pc + oreg</code></td>
  <td>Load program counter-relative address into areg</td>
</tr>
<tr>
  <td><code>LDAI</code></td>
  <td><code>areg := mem[areg + oreg]</code></td>
  <td>Load from memory with base and offset into areg</td>
</tr>
<tr>
  <td><code>LDBI</code></td>
  <td><code>breg := mem[breg + oreg]</code></td>
  <td>Load from memory with base and offset into breg</td>
</tr>
<tr>
  <td><code>STAI</code></td>
  <td><code>mem[breg + oreg] := areg</code></td>
  <td>Store to memory with base and offset from areg</td>
</tr>
<tr>
  <td><code>BR</code></td>
  <td><code>pc := pc + oreg</code></td>
  <td>Branch relative</td>
</tr>
<tr>
  <td><code>BRZ</code></td>
  <td><code>if areg = 0: pc := pc + oreg</code></td>
  <td>Conditional branch relative on areg being zero</td>
</tr>
<tr>
  <td><code>BRN</code></td>
  <td><code>if areg < 0: pc := pc + oreg</code></td>
  <td>Conditional branch relative on areg being negative</td>
</tr>
<tr>
  <td><code>BRB</code></td>
  <td><code>pc := breg</code></td>
  <td>Absolute branch</td>
</tr>
<tr>
  <td><code>PFIX</code></td>
  <td><code>oreg := oreg << 4</code></td>
  <td>Positive prefix</td>
</tr>
<tr>
  <td><code>NFIX</code></td>
  <td><code>oreg = 0xFFFFFF00 | oreg << 4</code></td>
  <td>Negative prefix</td>
</tr>
<tr>
  <td><code>OPR</code></td>
  <td>-</td>
  <td>Inter-register operation</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;<code>ADD</code></td>
  <td><code>areg := areg + breg</code></td>
  <td>Add areg and breg and set areg to the result</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;<code>SUB</code></td>
  <td><code>areg := areg - breg</code></td>
  <td>Subtract areg and breg and set areg to the result</td>
</tr>
<tr>
  <td>&nbsp;&nbsp;<code>SVC</code></td>
  <td>-</td>
  <td>Supervisor call</td>
</tr>
</table>

<h3>Prefixing</h3>
<p>Prefixing using&nbsp;the <code>PFIX</code> and <code>NFIX</code> operations generates operand values&nbsp;in <code>oreg</code> larger than the 4-bit instruction immediate. For example, the
following instructions generate the value 16&nbsp;in <code>oreg</code> and&nbsp;use <code>LDAC</code> to
assign it&nbsp;to <code>areg</code> :</p>
<div class="highlight"><pre><span></span><code>PFIX<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c1"># oreg = oreg (1) &lt;&lt; 4 (0x000010)</span>
LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># areg = oreg 16</span>
</code></pre></div>

<p>Prefixes can be chained to extend the operand range, for example, generating the
value 496 requires two positive prefixes before a load constant&nbsp;instruction:</p>
<div class="highlight"><pre><span></span><code>PFIX<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c1"># oreg = oreg (1) &lt;&lt; 4 (0x000010)</span>
PFIX<span class="w"> </span><span class="m">15</span><span class="w"> </span><span class="c1"># oreg = oreg (31) &lt;&lt; 4 (0x0001f0)</span>
LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># areg = oreg 496</span>
</code></pre></div>

<p>Negative values always require a negative prefix to fill the top&nbsp;most <code>oreg</code>
bits with ones, so to load the value -1&nbsp;into <code>oreg</code> then <code>areg</code>:</p>
<div class="highlight"><pre><span></span><code>NFIX<span class="w"> </span><span class="m">15</span><span class="w"> </span><span class="c1"># oreg = 0xFFFFFF00 | oreg (15) &lt;&lt; 4 (0xfffffff0)</span>
LDAC<span class="w"> </span><span class="m">15</span><span class="w"> </span><span class="c1"># areg = oreg 4294967295</span>
</code></pre></div>

<p>And to load -512, a positive prefix is required to scale the negative&nbsp;value:</p>
<div class="highlight"><pre><span></span><code>NFIX<span class="w"> </span><span class="m">14</span><span class="w"> </span><span class="c1"># oreg = 0xFFFFFF00 | oreg (14) &lt;&lt; 4 (0xffffffe0)</span>
PFIX<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># oreg = oreg (4294967264) &lt;&lt; 4 (0xfffffe00)</span>
LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># areg = oreg 4294966784</span>
</code></pre></div>

<h3>Inter-register&nbsp;operations</h3>
<p>The inter-register operations use&nbsp;the <code>OPR</code> opcode and consist only of
addition and subtraction. The group can be extended by implementing additional
immediate opcodes to add new operations to the processor (such as other
arithmetic and bitwise operations). The 4-bit immediate supports up to 16
inter-register operations without the need for prefixing, but many more with
prefixing and the according overhead to form larger immediates. The following
instruction sequence adds two numbers from fixed locations in memory, with the
result written&nbsp;to <code>areg</code>:</p>
<div class="highlight"><pre><span></span><code>LDAM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c1"># areg = mem[oreg (0x000001)] (7)</span>
LDBM<span class="w"> </span><span class="m">2</span><span class="w">  </span><span class="c1"># breg = mem[oreg (0x000002)] (9)</span>
OPR<span class="w">  </span><span class="m">1</span><span class="w">  </span><span class="c1"># ADD areg = areg (7) + breg (9) (16)</span>
</code></pre></div>

<p>A special inter-register operation is a supervisor call that transfers
control to the system to complete an action such as read or write from a
file, or to halt the program. The supervisor call type is encoded in&nbsp;the
<code>oreg</code> and arguments and return values specific to the call type are passed
and returned on the stack using the standard calling convention. An example
code sequence to invoke the exit supervisor call&nbsp;is:</p>
<div class="highlight"><pre><span></span><code>LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># Set areg to 0, the exit opcode value.</span>
LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c1"># Load the stack pointer in breg.</span>
STAI<span class="w"> </span><span class="m">2</span><span class="w">  </span><span class="c1"># Store areg into stack offset two as a parameter.</span>
LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># Load the exit opcode.</span>
OPR<span class="w"> </span>SVC<span class="w"> </span><span class="c1"># Perform the supervisor call</span>
</code></pre></div>

<p>With the following execution trace, noting that the simulator implements the
system call directly rather than being handled by a kernel&nbsp;routine:</p>
<div class="highlight"><pre><span></span><code>LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># areg = oreg 0</span>
LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="c1"># breg = mem[oreg (0x000001)] (16383)</span>
STAI<span class="w"> </span><span class="m">2</span><span class="w">  </span><span class="c1"># mem[breg (16383) + oreg (2) = 0x004001] = areg (0)</span>
LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># areg = oreg 0</span>
OPR<span class="w">  </span><span class="m">3</span><span class="w">  </span><span class="c1"># exit 0</span>
</code></pre></div>

<h3>Load-store&nbsp;operations</h3>
<p>There are two variants of load and store instructions: using absolute addresses
and addresses relative to a base address. Absolute addressing&nbsp;(<code>LDAM</code>,
<code>LDBM</code> and <code>STAM</code>) is intended to access objects in memory that are
allocated at offsets that are fixed with respect to a program, such as constant
values and global variables. Relative-addressing&nbsp;(<code>LDAI</code>, <code>LDBI</code> and
<code>STAI</code>) is typically used to access objects that are relative to a dynamic
position, such as the stack pointer, or index into an array. The particular
variants of load/store instructions is influenced by their targeting from a
compiler. Having pairs of load instructions that can write&nbsp;to <code>areg</code> or
<code>breg</code> (such&nbsp;as <code>LDAM</code> and <code>LDBM</code>) gives flexibility when generating
operands for binary operations, whereas having only single variants of stores&nbsp;(<code>STAM</code> and <code>STAI</code>) fits most cases where expression results generated&nbsp;into
<code>areg</code> need to be written to&nbsp;memory.</p>
<h3>Branching</h3>
<p>For branching, a relative branch is provided&nbsp;with <code>BR</code>, which can be used, for
example, to reach a label location. Conditional branch&nbsp;versions <code>BRZ</code> and
<code>BRN</code> are used to implement logical binary operations (less than, equal etc)&nbsp;and <code>BRB</code> is an absolute branch that is used, for example, to return to
a calling function using an address retrieved from memory (see example in next&nbsp;section).</p>
<h3>Address&nbsp;generation</h3>
<p>A special constant-loading&nbsp;instruction <code>LDAP</code> is used to generate bytewise
program addresses, relative to the program counter, such as for branch targets.
The following instruction sequence performs a call&nbsp;to <code>foo</code> but first loads
the return (link) address&nbsp;using <code>LDAP</code> to use&nbsp;with <code>BR</code>. The&nbsp;callee <code>foo</code>
returns to the caller&nbsp;using <code>BRB</code>.</p>
<div class="highlight"><pre><span></span><code>FUNC<span class="w"> </span>foo
LDBM<span class="w"> </span><span class="m">1</span>
STAI<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># Save caller address</span>
...
LDBI<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># Restore caller address</span>
OPR<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="c1"># Return to caller</span>

PROC<span class="w"> </span>main
...
LDAP<span class="w"> </span>lab2
BR<span class="w"> </span>foo
lab2
</code></pre></div>

<p>These instructions have the following execution&nbsp;trace:</p>
<div class="highlight"><pre><span></span><code>main+32<span class="w">  </span>LDAP<span class="w"> </span><span class="m">2</span><span class="w">   </span><span class="c1"># areg = pc (60) + oreg (2) 62</span>
main+33<span class="w">  </span>NFIX<span class="w"> </span><span class="m">13</span><span class="w">  </span><span class="c1"># oreg = 0xFFFFFF00 | oreg (13) &lt;&lt; 4 (0xffffffd0)</span>
main+34<span class="w">  </span>BR<span class="w">   </span><span class="m">1</span><span class="w">   </span><span class="c1"># pc = pc + oreg (4294967249) (0x00000f)</span>
foo+0<span class="w">    </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">   </span><span class="c1"># breg = mem[oreg (0x000001)] (199994)</span>
foo+1<span class="w">    </span>STAI<span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="c1"># mem[breg (199994) + oreg (0) = 0x030d3a] = areg (62)</span>
...
foo+10<span class="w">   </span>LDBI<span class="w"> </span><span class="m">0</span><span class="w">   </span><span class="c1"># breg = mem[breg (199994) + oreg (0) = 0x030d3a] (62)</span>
foo+11<span class="w">   </span>OPR<span class="w">  </span><span class="m">0</span><span class="w">   </span><span class="c1"># BRB pc = breg (0x00003e)</span>
main+35<span class="w">  </span>...
</code></pre></div>

<h2>The X language <a name="the-x-language" class="anchor"></a></h2>
<p>The X language is defined in <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/xhexnotes.pdf">a separate
<span class="caps">PDF</span></a>. X is simple enough that it can
be compiled using simple techniques to the Hex architecture, whilst providing
enough flexibility to express complex programs such as its own compiler (more
on that later). X is an imperative language and has features for procedure
calling, composition of statements, looping and conditional statements,
expressions including function calls, and representation of memory with
variables and arrays. To give an indicative example of X programming, the
following program implements Bubblesort to sort an array of four&nbsp;elements:</p>
<div class="highlight"><pre><span></span><code><span class="n">val</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="n">var</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">length</span><span class="p">];</span>

<span class="n">proc</span><span class="w"> </span><span class="nf">sort</span><span class="p">(</span><span class="n">array</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">is</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">tmp</span><span class="p">;</span>
<span class="p">{</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="p">{</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">then</span>
<span class="w">      </span><span class="p">{</span><span class="w"> </span><span class="n">tmp</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
<span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tmp</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="k">else</span><span class="w"> </span><span class="n">skip</span>
<span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">proc</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="n">is</span>
<span class="p">{</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">3</span>
<span class="p">;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">2</span>
<span class="p">;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">1</span>
<span class="p">;</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span>
<span class="p">;</span><span class="w"> </span><span class="n">sort</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">length</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>Limitations of X to note that simplify its implementation&nbsp;are:</p>
<ul>
<li>
<p>Arrays are limited to one&nbsp;dimension.</p>
</li>
<li>
<p>No operator precedence to avoid built-in rules so precedence must be
  indicated explicitly with bracketing (apart from associative&nbsp;operators).</p>
</li>
<li>
<p>Conditional statements&nbsp;(beginning <code>if</code>) must always have&nbsp;an <code>else</code> part
  to simplify&nbsp;parsing.</p>
</li>
<li>
<p>Variables can only be passed by value into&nbsp;procedures.</p>
</li>
<li>
<p>There is no block scoping so variable and array declarations can only be made
  at global and procedure scopes. Similarly, nested definitions of procedures
  are not&nbsp;permitted.</p>
</li>
</ul>
<p>Other noteworthy features of X&nbsp;are:</p>
<ul>
<li>
<p>There are two types of procedure: <strong>processes</strong> (using&nbsp;the <code>proc</code> keyword)
  that execute a sequence of steps with possible side effects, and
  <strong>functions</strong> (using&nbsp;the <code>func</code>keyword ) that have no side effects and return
  a&nbsp;value.</p>
</li>
<li>
<p>Names in a program are introduced as <strong>definitions</strong> of processes or functions,
  <strong>declarations</strong> that represent memory locations, and <strong>abbreviations</strong> that
  introduce alternative names for expressions, arrays, processes and&nbsp;functions.</p>
</li>
<li>
<p>The scoping and abbreviation rules are defined so that that actual parameters
  act as abbreviations of the supplied formals. This allows processes and
  functions to be compiled by either as closed subroutines or by substitution of
  the body at the call site, either as a source code transformation or compiler
  optimisation. For example, given the&nbsp;definition <code>proc foo(val a, array b) is B</code>,
  it can be called as a&nbsp;subroutine: <code>foo(x, y)</code> or&nbsp;substituted: <code>val a = x; array b = y; B</code>
  providing the names are unique in the&nbsp;procedure.</p>
</li>
<li>
<p>A <code>valof</code> element allows processes to be called from expressions to
  generate values, however it is not implemented&nbsp;in <code>xhexb</code> or <code>xcmp</code>.</p>
</li>
</ul>
<h2>Hex processor integrated circuit <a name="hex-processor-integrated-circuit" class="anchor"></a></h2>
<p>A hardware implementation of the Hex processor is written in System Verilog,
<a href="https://github.com/jameshanlon/hex-processor/blob/master/verilog/processor.sv"><code>processor.sv</code></a>,
in just 150 lines. This implementation is single cycle in that all elements of
instruction execution (ie instruction fetch from memory, decode, instruction
memory access and state writeback) are completed in that time. A separate
memory module,
<a href="https://github.com/jameshanlon/hex-processor/blob/master/verilog/memory.sv"><code>memory.sv</code></a>
implements a single-cycle random-access memory with two ports: one for
instruction fetch and the other for data access so that they can occur
simultaneously in the same cycle. Note that because memory access time
increases with the memory capacity, a implementation of Hex accessing a large
memory (ie more than a few thousand bytes) would add pipelining to hide the
latency to memory. Some degree of pipelining is standard in processor
implementations. The hardware design is simulated using Verilator, with C++
testbench driver code in <a href="https://github.com/jameshanlon/hex-processor/blob/master/hextb.cpp"><code>hextb.cpp</code></a>.</p>
<p>Using <a href="https://theopenroadproject.org/">OpenROAD</a>, an open-source tool chain
for performing synthesis, optimisation and physical layout of digital circuits,
we can compile Hex into an integrated circuit layout in order that it could be
manufactured into a silicon device. OpenROAD uses the
<a href="https://github.com/google/skywater-pdk">SkyWater Process Design Kit</a> (<span class="caps">PDK</span>),
for creating designs in 130 nm process technology, which was a technology first
commercialised in 2001. The <span class="caps">PDK</span> is a collection of analog and digital cell
libraries, design rules and tooling. Since OpenROAD uses
<a href="https://yosyshq.net/yosys/">Yosys</a> for synthesis, and it doesn&#8217;t support
particular SystemVerilog features, I used
<a href="https://github.com/zachjs/sv2v">sv2v</a> to convert the implementation to plain
Verilog 2005 (see <a href="https://github.com/jameshanlon/hex-processor/blob/master/verilog/processor.v"><code>processor.v</code></a>).</p>
<p>The physical design is based on an OpenROAD <a href="https://openroad.readthedocs.io/en/latest/tutorials/FlowTutorial.html">default
flow</a>,
which takes a few minutes to be compiled from the source <span class="caps">RTL</span>. The final design
has the following&nbsp;characteristics:</p>
<ul>
<li>A die size of ~280x280&nbsp;microns.</li>
<li>A total of 9,719 standard&nbsp;cells.</li>
<li>A cell area of 16,706 square microns at 25%&nbsp;utilisation.</li>
<li>A clock speed of 229&nbsp;MHz.</li>
<li>Total switching power of 4.12&nbsp;mW.</li>
</ul>
<p>The OpenROAD <span class="caps">GUI</span> provides many ways to visualise and explore the design. The
following images are some examples of the different&nbsp;views.</p>
<div class="container">
  <div class="row align-items-center">
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-stdcells.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-stdcells_600x600.png" alt="Floorplan showing the standard cells only, with the two lowest metal layers (logic and M1).">
  </a>
  <figcaption class="figure-caption text-left">Floorplan showing the standard cells only, with the two lowest metal layers (logic and M1).</figcaption>
</figure>
</div>

    </div>
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-closeup.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-closeup_600x600.png" alt="A zoomed view showing standard cells with logic and M1 layers only.">
  </a>
  <figcaption class="figure-caption text-left">A zoomed view showing standard cells with logic and M1 layers only.</figcaption>
</figure>
</div>

    </div>
  </div>
</div>

<div class="container">
  <div class="row align-items-center">
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-clocktree.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-clocktree_600x600.png" alt="A view showing all nets constituting the clock tree.">
  </a>
  <figcaption class="figure-caption text-left">A view showing all nets constituting the clock tree.</figcaption>
</figure>
</div>

    </div>
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-routing-congestion.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-routing-congestion_600x600.png" alt="A heatmap view representing routing congestion.">
  </a>
  <figcaption class="figure-caption text-left">A heatmap view representing routing congestion.</figcaption>
</figure>
</div>

    </div>
  </div>
</div>

<div class="container">
  <div class="row align-items-center">
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-setup-worstpath.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-setup-worstpath_600x600.png" alt="A visualisation of the worst setup path in the design, including the nets and cells on the path as well as the paths for the launch and capture clocks.">
  </a>
  <figcaption class="figure-caption text-left">A visualisation of the worst setup path in the design, including the nets and cells on the path as well as the paths for the launch and capture clocks.</figcaption>
</figure>
</div>

    </div>
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/floorplan-hold-worstpath.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/floorplan-hold-worstpath_600x600.png" alt="The same visualisation for the worst (least slack) hold path in the design.">
  </a>
  <figcaption class="figure-caption text-left">The same visualisation for the worst (least slack) hold path in the design.</figcaption>
</figure>
</div>

    </div>
  </div>
</div>

<h2>Hex tooling <a name="hex-tooling" class="anchor"></a></h2>
<p>There are three tools provided in the Hex toolchain: a Hex instruction set&nbsp;simulator <code>hexsim</code>, a Hex&nbsp;assembler <code>hexasm</code> and an X&nbsp;compiler <code>xcmp</code>.
Instructions on how to build the tools are included in the
<a href="https://jameshanlon.github.io/hex-processor">documentation</a>.
The implementation is provided in a small number of source files (with only one
external dependency&nbsp;on <code>boost::format</code>):</p>
<ul>
<li>
<p>General Hex definitions are provided in
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hex.hpp"><code>hex.hpp</code></a> and
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hex.cpp"><code>hex.cpp</code></a>.</p>
</li>
<li>
<p>The Hex simulator is implemented in the headers
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hexsim.hpp"><code>hexsim.hpp</code></a> and
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hexsimio.hpp"><code>hexsimio.hpp</code></a>.
  (Note that listings for a complete simulator in C are given in the <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/hexb.pdf">Hex definition (<span class="caps">PDF</span>)</a>.)</p>
</li>
<li>
<p>The Hex assembler is implemented in the header
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hexasm.hpp"><code>hexasm.hpp</code></a>.</p>
</li>
<li>
<p>The X compiler is implemented in the header
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/xcmp.hpp"><code>xcmp.hpp</code></a>.</p>
</li>
<li>
<p>Driver code for the respective command-line&nbsp;tools <code>hexsim</code>, <code>hexasm</code> and
  <code>xcmp</code> is implemented in
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hexsim.cpp"><code>hexsim.cpp</code></a>,
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/hexasm.cpp"><code>hexasm.cpp</code></a> and
  <a href="https://github.com/jameshanlon/hex-processor/blob/master/xcmp.cpp"><code>xcmp.cpp</code></a>.</p>
</li>
</ul>
<h3>A simple&nbsp;example</h3>
<p>Taking a most basic example of an assembly program that simply&nbsp;exits:</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>cat<span class="w"> </span>tests/asm/exit0.S
BR<span class="w"> </span>start
DATA<span class="w"> </span><span class="m">16383</span><span class="w"> </span><span class="c1"># sp</span>
start
LDAC<span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="c1"># areg &lt;- 0</span>
LDBM<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="c1"># breg &lt;- sp</span>
STAI<span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="c1"># sp[2] &lt;- areg</span>
LDAC<span class="w"> </span><span class="m">0</span>
OPR<span class="w"> </span>SVC
</code></pre></div>

<p>The assembler can display the program layout in memory and computed symbol&nbsp;values:</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>hexasm<span class="w"> </span>tests/asm/exit0.S<span class="w"> </span>--instrs
<span class="m">00000000</span><span class="w"> </span>BR<span class="w"> </span>start<span class="w"> </span><span class="o">(</span><span class="m">7</span><span class="o">)</span><span class="w">         </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
0x000004<span class="w"> </span>DATA<span class="w"> </span><span class="m">16383</span><span class="w">           </span><span class="o">(</span><span class="m">4</span><span class="w"> </span>bytes<span class="o">)</span>
0x000008<span class="w"> </span>start<span class="w">                </span><span class="o">(</span><span class="m">0</span><span class="w"> </span>bytes<span class="o">)</span>
0x000008<span class="w"> </span>LDAC<span class="w"> </span><span class="m">0</span><span class="w">               </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
0x000009<span class="w"> </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">               </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
0x00000a<span class="w"> </span>STAI<span class="w"> </span><span class="m">2</span><span class="w">               </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
0x00000b<span class="w"> </span>LDAC<span class="w"> </span><span class="m">0</span><span class="w">               </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
0x00000c<span class="w"> </span>OPR<span class="w"> </span>SVC<span class="w">              </span><span class="o">(</span><span class="m">1</span><span class="w"> </span>bytes<span class="o">)</span>
<span class="m">00000000</span><span class="w"> </span>PADDING<span class="w"> </span><span class="m">3</span><span class="w">            </span><span class="o">(</span><span class="m">3</span><span class="w"> </span>bytes<span class="o">)</span>
<span class="m">13</span><span class="w"> </span>bytes
</code></pre></div>

<p>And create a 13-byte executable&nbsp;binary:</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>hexasm<span class="w"> </span>tests/asm/exit0.S
</code></pre></div>

<p>This binary can then be simulated with tracing to show what&#8217;s going on (the
first column is the cycle count and the second is&nbsp;the <code>pc</code> value):</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>hexsim<span class="w"> </span>a.out<span class="w"> </span>-t
<span class="m">0</span><span class="w">      </span><span class="m">0</span><span class="w">      </span>BR<span class="w">   </span><span class="m">7</span><span class="w">  </span><span class="nv">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pc<span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">7</span><span class="o">)</span><span class="w"> </span><span class="o">(</span>0x000008<span class="o">)</span>
<span class="m">1</span><span class="w">      </span><span class="m">8</span><span class="w">      </span>LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="nv">areg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>oreg<span class="w"> </span><span class="m">0</span>
<span class="m">2</span><span class="w">      </span><span class="m">9</span><span class="w">      </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="nv">breg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mem<span class="o">[</span>oreg<span class="w"> </span><span class="o">(</span>0x000001<span class="o">)]</span><span class="w"> </span><span class="o">(</span><span class="m">16383</span><span class="o">)</span>
<span class="m">3</span><span class="w">      </span><span class="m">10</span><span class="w">     </span>STAI<span class="w"> </span><span class="m">2</span><span class="w">  </span>mem<span class="o">[</span>breg<span class="w"> </span><span class="o">(</span><span class="m">16383</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x004001<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>areg<span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="o">)</span>
<span class="m">4</span><span class="w">      </span><span class="m">11</span><span class="w">     </span>LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="nv">areg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>oreg<span class="w"> </span><span class="m">0</span>
<span class="m">5</span><span class="w">      </span><span class="m">12</span><span class="w">     </span>OPR<span class="w">  </span><span class="m">3</span><span class="w">  </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
</code></pre></div>

<p>The X compiler can be used to produce more complex Hex programs. Starting with
a similar most basic program  written in&nbsp;X:</p>
<div class="highlight"><pre><span></span><code><span class="k">proc</span><span class="w"> </span><span class="nv">main</span><span class="p">()</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">skip</span>
</code></pre></div>

<p>This null program is compiled into Hex assembly, where the entry code&nbsp;calls
<code>main</code> then exits,&nbsp;and <code>main</code> does nothing (apart from saving and restoring
the link&nbsp;location):</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>xcmp<span class="w"> </span>tests/x/exit.x<span class="w"> </span>--insts-lowered
BR<span class="w"> </span>start
DATA<span class="w"> </span><span class="m">199999</span>
start
LDAP<span class="w"> </span>_exit
BR<span class="w"> </span>main
_exit
LDBM<span class="w"> </span><span class="m">1</span>
LDAC<span class="w"> </span><span class="m">0</span>
STAI<span class="w"> </span><span class="m">2</span>
OPR<span class="w"> </span>SVC

PROC<span class="w"> </span>main
LDBM<span class="w"> </span><span class="m">1</span>
STAI<span class="w"> </span><span class="m">0</span>
lab0
LDBM<span class="w"> </span><span class="m">1</span>
LDBI<span class="w"> </span><span class="m">0</span>
OPR<span class="w"> </span>BRB
</code></pre></div>

<p>And when simulated produces the following trace where execution&nbsp;through
<code>main</code> can be seen since it is the only labelled portion of the&nbsp;code:</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>hexsim<span class="w"> </span>a.out<span class="w"> </span>-t
<span class="m">0</span><span class="w">      </span><span class="m">0</span><span class="w">                   </span>BR<span class="w">   </span><span class="m">7</span><span class="w">  </span><span class="nv">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pc<span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">7</span><span class="o">)</span><span class="w"> </span><span class="o">(</span>0x000008<span class="o">)</span>
<span class="m">1</span><span class="w">      </span><span class="m">8</span><span class="w">                   </span>LDAP<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="nv">areg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pc<span class="w"> </span><span class="o">(</span><span class="m">9</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">1</span><span class="o">)</span><span class="w"> </span><span class="m">10</span>
<span class="m">2</span><span class="w">      </span><span class="m">9</span><span class="w">                   </span>BR<span class="w">   </span><span class="m">4</span><span class="w">  </span><span class="nv">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>pc<span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">4</span><span class="o">)</span><span class="w"> </span><span class="o">(</span>0x00000e<span class="o">)</span>
<span class="m">3</span><span class="w">      </span><span class="m">14</span><span class="w">     </span>main+0<span class="w">       </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="nv">breg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mem<span class="o">[</span>oreg<span class="w"> </span><span class="o">(</span>0x000001<span class="o">)]</span><span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span>
<span class="m">4</span><span class="w">      </span><span class="m">15</span><span class="w">     </span>main+1<span class="w">       </span>STAI<span class="w"> </span><span class="m">0</span><span class="w">  </span>mem<span class="o">[</span>breg<span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x030d3f<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>areg<span class="w"> </span><span class="o">(</span><span class="m">10</span><span class="o">)</span>
<span class="m">5</span><span class="w">      </span><span class="m">16</span><span class="w">     </span>main+2<span class="w">       </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="nv">breg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mem<span class="o">[</span>oreg<span class="w"> </span><span class="o">(</span>0x000001<span class="o">)]</span><span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span>
<span class="m">6</span><span class="w">      </span><span class="m">17</span><span class="w">     </span>main+3<span class="w">       </span>LDBI<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="nv">breg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mem<span class="o">[</span>breg<span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x030d3f<span class="o">]</span><span class="w"> </span><span class="o">(</span><span class="m">10</span><span class="o">)</span>
<span class="m">7</span><span class="w">      </span><span class="m">18</span><span class="w">     </span>main+4<span class="w">       </span>OPR<span class="w">  </span><span class="m">0</span><span class="w">  </span>BRB<span class="w"> </span><span class="nv">pc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>breg<span class="w"> </span><span class="o">(</span>0x00000a<span class="o">)</span>
<span class="m">8</span><span class="w">      </span><span class="m">10</span><span class="w">                  </span>LDBM<span class="w"> </span><span class="m">1</span><span class="w">  </span><span class="nv">breg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mem<span class="o">[</span>oreg<span class="w"> </span><span class="o">(</span>0x000001<span class="o">)]</span><span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span>
<span class="m">9</span><span class="w">      </span><span class="m">11</span><span class="w">                  </span>LDAC<span class="w"> </span><span class="m">0</span><span class="w">  </span><span class="nv">areg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>oreg<span class="w"> </span><span class="m">0</span>
<span class="m">10</span><span class="w">     </span><span class="m">12</span><span class="w">                  </span>STAI<span class="w"> </span><span class="m">2</span><span class="w">  </span>mem<span class="o">[</span>breg<span class="w"> </span><span class="o">(</span><span class="m">199999</span><span class="o">)</span><span class="w"> </span>+<span class="w"> </span>oreg<span class="w"> </span><span class="o">(</span><span class="m">2</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>0x030d41<span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>areg<span class="w"> </span><span class="o">(</span><span class="m">0</span><span class="o">)</span>
<span class="m">11</span><span class="w">     </span><span class="m">13</span><span class="w">                  </span>OPR<span class="w">  </span><span class="m">3</span><span class="w">  </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
</code></pre></div>

<p>The program can also be run on the Verilog Hex implementation&nbsp;using <code>hextb</code>
(which doesn&#8217;t provide as rich instruction tracing&nbsp;as <code>hexsim</code>):</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>hextb<span class="w"> </span>a.out<span class="w"> </span>-t
Wrote<span class="w"> </span><span class="m">20</span><span class="w"> </span>bytes<span class="w"> </span>to<span class="w"> </span>memory
<span class="o">[</span><span class="m">11</span><span class="o">]</span><span class="w"> </span><span class="m">8</span><span class="w">      </span>0x51<span class="w"> </span>LDAP
<span class="o">[</span><span class="m">13</span><span class="o">]</span><span class="w"> </span><span class="m">9</span><span class="w">      </span>0x94<span class="w"> </span>BR
<span class="o">[</span><span class="m">15</span><span class="o">]</span><span class="w"> </span><span class="m">14</span><span class="w">     </span>0x11<span class="w"> </span>LDBM
<span class="o">[</span><span class="m">17</span><span class="o">]</span><span class="w"> </span><span class="m">15</span><span class="w">     </span>0x80<span class="w"> </span>STAI
<span class="o">[</span><span class="m">19</span><span class="o">]</span><span class="w"> </span><span class="m">16</span><span class="w">     </span>0x11<span class="w"> </span>LDBM
<span class="o">[</span><span class="m">21</span><span class="o">]</span><span class="w"> </span><span class="m">17</span><span class="w">     </span>0x70<span class="w"> </span>LDBI
<span class="o">[</span><span class="m">23</span><span class="o">]</span><span class="w"> </span><span class="m">18</span><span class="w">     </span>0xd0<span class="w"> </span>OPR
<span class="o">[</span><span class="m">25</span><span class="o">]</span><span class="w"> </span><span class="m">10</span><span class="w">     </span>0x11<span class="w"> </span>LDBM
<span class="o">[</span><span class="m">27</span><span class="o">]</span><span class="w"> </span><span class="m">11</span><span class="w">     </span>0x30<span class="w"> </span>LDAC
<span class="o">[</span><span class="m">29</span><span class="o">]</span><span class="w"> </span><span class="m">12</span><span class="w">     </span>0x82<span class="w"> </span>STAI
<span class="o">[</span><span class="m">31</span><span class="o">]</span><span class="w"> </span><span class="m">13</span><span class="w">     </span>0xd3<span class="w"> </span>OPR
<span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
</code></pre></div>

<h3>Hello&nbsp;World</h3>
<p>A more fulsome example is &#8216;Hello World&#8217;, where the main process is&nbsp;simply:</p>
<div class="highlight"><pre><span></span><code><span class="k">proc</span><span class="w"> </span><span class="nv">main</span><span class="p">()</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">prints</span><span class="p">(</span><span class="s">&quot;hello world\n&quot;</span><span class="p">)</span>
</code></pre></div>

<p>And <code>prints</code> unpacks the bytewise string representation by using routines for
performing division and remainder by 265. The full program listing&nbsp;is:</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>cat<span class="w"> </span>tests/x/hello_prints.x
val<span class="w"> </span><span class="nv">put</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
val<span class="w"> </span><span class="nv">bytesperword</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">4</span><span class="p">;</span>
var<span class="w"> </span>div_x<span class="p">;</span>

proc<span class="w"> </span>main<span class="o">()</span><span class="w"> </span>is<span class="w"> </span>prints<span class="o">(</span><span class="s2">&quot;hello world\n&quot;</span><span class="o">)</span>

proc<span class="w"> </span>putval<span class="o">(</span>val<span class="w"> </span>c<span class="o">)</span><span class="w"> </span>is<span class="w"> </span>put<span class="o">(</span>c,<span class="w"> </span><span class="m">0</span><span class="o">)</span>

func<span class="w"> </span>lsu<span class="o">(</span>val<span class="w"> </span>x,<span class="w"> </span>val<span class="w"> </span>y<span class="o">)</span><span class="w"> </span>is
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>x<span class="w"> </span>&lt;<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span>y<span class="w"> </span>&lt;<span class="w"> </span><span class="m">0</span><span class="o">)</span>
<span class="w">  </span><span class="k">then</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>x<span class="w"> </span>&lt;<span class="w"> </span>y
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>y<span class="w"> </span>&lt;<span class="w"> </span><span class="m">0</span>

func<span class="w"> </span>div_step<span class="o">(</span>val<span class="w"> </span>b,<span class="w"> </span>val<span class="w"> </span>y<span class="o">)</span><span class="w"> </span>is
<span class="w">  </span>var<span class="w"> </span>r<span class="p">;</span>
<span class="o">{</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">(</span>y<span class="w"> </span>&lt;<span class="w"> </span><span class="m">0</span><span class="o">)</span><span class="w"> </span>or<span class="w"> </span><span class="o">(</span>~lsu<span class="o">(</span>y,<span class="w"> </span>div_x<span class="o">))</span>
<span class="w">  </span><span class="k">then</span>
<span class="w">    </span>r<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span>r<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>div_step<span class="o">(</span>b<span class="w"> </span>+<span class="w"> </span>b,<span class="w"> </span>y<span class="w"> </span>+<span class="w"> </span>y<span class="o">)</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span>~lsu<span class="o">(</span>div_x,<span class="w"> </span>y<span class="o">)</span>
<span class="w">  </span><span class="k">then</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span>div_x<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>div_x<span class="w"> </span>-<span class="w"> </span>y<span class="p">;</span>
<span class="w">    </span>r<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>r<span class="w"> </span>+<span class="w"> </span>b
<span class="w">  </span><span class="o">}</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span>skip<span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span>r
<span class="o">}</span>

func<span class="w"> </span>div<span class="o">(</span>val<span class="w"> </span>n,<span class="w"> </span>val<span class="w"> </span>m<span class="o">)</span><span class="w"> </span>is
<span class="o">{</span><span class="w"> </span>div_x<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>n<span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span>lsu<span class="o">(</span>n,<span class="w"> </span>m<span class="o">)</span>
<span class="w">  </span><span class="k">then</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="m">0</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span>div_step<span class="o">(</span><span class="m">1</span>,<span class="w"> </span>m<span class="o">)</span>
<span class="o">}</span>

func<span class="w"> </span>rem<span class="o">(</span>val<span class="w"> </span>n,<span class="w"> </span>val<span class="w"> </span>m<span class="o">)</span><span class="w"> </span>is
<span class="w">  </span>var<span class="w"> </span>x<span class="p">;</span>
<span class="o">{</span><span class="w"> </span>x<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>div<span class="o">(</span>n,<span class="w"> </span>m<span class="o">)</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span>div_x
<span class="o">}</span>

proc<span class="w"> </span>prints<span class="o">(</span>array<span class="w"> </span>s<span class="o">)</span><span class="w"> </span>is
<span class="w">  </span>var<span class="w"> </span>n<span class="p">;</span>
<span class="w">  </span>var<span class="w"> </span>p<span class="p">;</span>
<span class="w">  </span>var<span class="w"> </span>w<span class="p">;</span>
<span class="w">  </span>var<span class="w"> </span>l<span class="p">;</span>
<span class="w">  </span>var<span class="w"> </span>b<span class="p">;</span>
<span class="o">{</span><span class="w"> </span>n<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span>p<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">  </span>w<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>s<span class="o">[</span>p<span class="o">]</span><span class="p">;</span>
<span class="w">  </span>l<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>rem<span class="o">(</span>w,<span class="w"> </span><span class="m">256</span><span class="o">)</span><span class="p">;</span>
<span class="w">  </span>w<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>div<span class="o">(</span>w,<span class="w"> </span><span class="m">256</span><span class="o">)</span><span class="p">;</span>
<span class="w">  </span>b<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="o">(</span>n<span class="w"> </span>&lt;<span class="o">=</span><span class="w"> </span>l<span class="o">)</span><span class="w"> </span><span class="k">do</span>
<span class="w">  </span><span class="o">{</span><span class="w"> </span>putval<span class="o">(</span>rem<span class="o">(</span>w,<span class="w"> </span><span class="m">256</span><span class="o">))</span><span class="p">;</span>
<span class="w">    </span>w<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>div<span class="o">(</span>w,<span class="w"> </span><span class="m">256</span><span class="o">)</span><span class="p">;</span>
<span class="w">    </span>n<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>n<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">    </span>b<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>b<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>bytesperword<span class="o">)</span>
<span class="w">    </span><span class="k">then</span>
<span class="w">    </span><span class="o">{</span><span class="w"> </span>b<span class="w"> </span>:<span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="w">      </span>p<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>p<span class="w"> </span>+<span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">      </span>w<span class="w"> </span>:<span class="o">=</span><span class="w"> </span>s<span class="o">[</span>p<span class="o">]</span>
<span class="w">    </span><span class="o">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span>skip
<span class="w">  </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<p>Compiling and running this shows that it takes ~50K cycles to execute and
inspecting the trace is clear to see that most time is spent in the arithmetic&nbsp;routines.</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>xcmp<span class="w"> </span>tests/x/hello_prints.x
â<span class="w"> </span>hexsim<span class="w"> </span>a.out
hello<span class="w"> </span>world
â<span class="w"> </span>hexsim<span class="w"> </span>a.out<span class="w"> </span>-t
...
<span class="m">48902</span><span class="w">  </span><span class="m">61</span><span class="w">                  </span>OPR<span class="w">  </span><span class="m">3</span><span class="w">  </span><span class="nb">exit</span><span class="w"> </span><span class="m">0</span>
</code></pre></div>

<h3>Building an X compiler and&nbsp;bootstrapping</h3>
<p>A third example is a complete compiler for X, written in X:
<a href="https://github.com/jameshanlon/hex-processor/blob/master/tests/x/xhexb.x"><code>xhexb.x</code></a>
written by David May in ~3,000 lines of X. This serves as a challenging program
to compile, and interesting that it can bootstrap itself. Using the notation
X(Y) to mean compile source Y using binary X, we can first create&nbsp;an <code>xhexb</code>
binary by&nbsp;running <code>xcmp</code>(<code>xhexb.x</code>):</p>
<div class="highlight"><pre><span></span><code>â<span class="w"> </span>xcmp<span class="w"> </span>-S<span class="w"> </span>tests/x/xhexb.x
...
<span class="m">20739</span><span class="w"> </span>bytes
</code></pre></div>

<p>We can then&nbsp;use <code>xcmp</code>(<code>xhexb.x</code>) to compile Hello World&nbsp;as
<code>xcmp</code>(<code>xhexb.x</code>)(<code>hello_prints.x</code>):</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Create an xhexb compiler binary.</span>
â<span class="w"> </span>xcmp<span class="w"> </span>tests/x/xhexb.x

<span class="c1"># Compile Hello World.</span>
â<span class="w"> </span>hexsim<span class="w"> </span>a.out<span class="w"> </span>&lt;<span class="w"> </span>tests/x/hello_prints.x
tree<span class="w"> </span>size:<span class="w"> </span><span class="m">602</span>
program<span class="w"> </span>size:<span class="w"> </span><span class="m">414</span>
size:<span class="w"> </span><span class="m">414</span>

<span class="c1"># Run it.</span>
â<span class="w"> </span>hexsim<span class="w"> </span>simout2
hello<span class="w"> </span>world
</code></pre></div>

<p>Similarly, we can&nbsp;use <code>xcmp</code>(<code>xhexb.x</code>) to bootstrap itself by&nbsp;running
<code>xcmp</code>(<code>xhexb.x</code>)(<code>xhexb.x</code>):</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Create an xhexb compiler binary.</span>
â<span class="w"> </span>xcmp<span class="w"> </span>tests/x/xhexb.x

<span class="c1"># Use xhexb binary to compile xhexb.x.</span>
â<span class="w"> </span>hexsim<span class="w"> </span>a.out<span class="w"> </span>&lt;<span class="w"> </span>tests/x/xhexb.x
tree<span class="w"> </span>size:<span class="w"> </span><span class="m">18631</span>
program<span class="w"> </span>size:<span class="w"> </span><span class="m">17093</span>
size:<span class="w"> </span><span class="m">177097</span>

<span class="c1"># Use the bootstrapped xhexb binary to compile Hello World.</span>
â<span class="w"> </span>hexsim<span class="w"> </span>simout2<span class="w"> </span>&lt;<span class="w"> </span>tests/x/hello_prints.x
tree<span class="w"> </span>size:<span class="w"> </span><span class="m">602</span>
program<span class="w"> </span>size:<span class="w"> </span><span class="m">414</span>
size:<span class="w"> </span><span class="m">414</span>

<span class="c1"># Run it.</span>
â<span class="w"> </span>hexsim<span class="w"> </span>simout2
hello<span class="w"> </span>world
</code></pre></div>

<h3>Implementation&nbsp;details</h3>
<p>Both the assembler and compiler are based on&nbsp;the <code>xhexb.x</code> bootstrapping
compiler for X discussed&nbsp;above.</p>
<p>The assembler works in two main&nbsp;phases:</p>
<ul>
<li>Parsing the program to form a list of directives (instructions, labels, data&nbsp;etc).</li>
<li>Code generation to iterate through the directives and emit binary&nbsp;output.</li>
</ul>
<p>Before emission, the value of labels must be determined, which involves solving two
problems. The first is that for a given relative reference, the length of the
encoding (ie number of prefixes) depends on the value of the reference and vice
versa. This is solved by iteratively increasing the encoding length until it
meets the required range&nbsp;(see <code>instrLen()</code>). The second problem is that the
value of a relative reference depends on the length of any relative encodings
contained within the range. This is solved by iteratively updating label values
until they reach a stable state&nbsp;(see <code>resolveLabels()</code>). The assembler adds
additional rudimentary debug information to the binary, with a mapping of
instruction ranges to symbol values. This allows the simulator to display the
current symbol and&nbsp;offset.</p>
<p>The compiler works a traditional way, structured as a sequence of phases, first
creating a parse tree, then performing passes on the tree to optimise it and
then lowering the tree to machine&nbsp;instructions:</p>
<ul>
<li>Parse the program to form an abstract syntax&nbsp;tree.</li>
<li>Walk the tree to populate a symbol table with names occurring in the&nbsp;program.</li>
<li>Walk the tree to propagate constant values within&nbsp;expressions.</li>
<li>Walk the tree to transform expressions into a canonical&nbsp;form.</li>
<li>Walk the tree to generate a sequence of intermediate machine&nbsp;instructions.</li>
<li>Lower the intermediate instructions to machine&nbsp;instructions.</li>
<li>Optimise the machine instruction&nbsp;sequence.</li>
<li>Assemble and emit the machine instruction&nbsp;sequence.</li>
</ul>
<p>Command line options such&nbsp;as <code>--tree</code> are available to inspect the internal
representation of the program in between these&nbsp;stages.</p>
<p>Compared with a more sophisticated compiler, Hex and X afford two significant
simplifications. First, the small set of features in X make it straightforward
to map to directly to machine instructions rather than an intermediate
machine-independent representation. Secondly, the register architecture of Hex
means that allocation of registers can be handled easily during mapping to
machine instructions, rather than having to allocate physical registers to a
virtual set as is typical in machines with more&nbsp;registers.</p>
<p>More details of&nbsp;the <code>xhexb</code> compiler implementation are included in the <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/hex-processor/xhexnotes.pdf">X
and Hex notes <span class="caps">PDF</span></a>, with aspects such as the
calling convention, handling of operators and arithmetic and memory layout
being shared&nbsp;in <code>xcmp</code>.</p>
<h2>A historical note <a name="a-historical-note" class="anchor"></a></h2>
<p>Hex, apart from being related to the Transputer, has some other interesting
historical roots. David May learned about languages and compilers from <a href="https://www.cl.cam.ac.uk/~mr10/">Martin
Richards</a> who was a young lecturer when David
completed his final-year Computer Science course as a student at King&#8217;s College
Cambridge (the first student to do so). Martin was the designer of the
influential language <span class="caps">BCPL</span> and its portable compiler technology. <span class="caps">BCPL</span> <a href="https://arstechnica.com/features/2020/12/a-damn-stupid-thing-to-do-the-origins-of-c/">found its
way</a>
to Bell Labs where <span class="caps">UNIX</span> was being developed. <span class="caps">BCPL</span> was the direct precursor to C
and so led to the portability of <span class="caps">UNIX</span>.</p>
<p>When David moved from Cambridge to Warwick, the only useful language on the
Modular One minicomputer that was available was <span class="caps">BCPL</span> but the compiler was
incomplete. So David completed the compiler and ported <span class="caps">BCPL</span> to other
computers, including some microprocessors. Using techniques similar to <span class="caps">BCPL</span>&#8217;s
bootstrapping compiler and interpreter, David designed and implemented a
concurrent language (<span class="caps">EPL</span>), bringing him into contact with Tony Hoare and Iann
Barron (founder of the company that designed the Modular One and also of&nbsp;Inmos).</p>
<p>David employed the same techniques again at Inmos to build the first implementation of
Occam in the 1980s and then again in 2008 for the project that led to the founding
of <span class="caps">XMOS</span> (incidentally, I used this compiler in my PhD work to demonstrate
techniques of compiling message-passing programs). Hex and X follow directly from
the <span class="caps">BCPL</span>-derived approaches, used by David as a tool to teach students about
instruction sets, compilers, bootstrapping&nbsp;etc.</p>
<h2>Summary <a name="summary" class="anchor"></a></h2>
<p>Modern processors, languages, compilers, and tooling are complex and difficult
to understand. This note walks through possibly the simplest processor
architecture that allows a compact implementation of rudimentary tooling and a
complete high-level programming language to be targeted at it. The definitions
and implementations are contained in a single repository and just a small set
of source files, making it an excellent project to use to explore processors
and&nbsp;compilers.</p>
<h2>Similar projects <a name="similar-projects" class="anchor"></a></h2>
<p>The following are some similar projects that include simple implementations of
processor&nbsp;toolchains.</p>
<ul>
<li>
<p><a href="https://www.cl.cam.ac.uk/~mr10/VSPL.html"><span class="caps">VSPL</span></a>, is a very simple
  programming language designed by Martin Richards to be used as a case study
  for comparing compiler implementations. The provided source distribution
  includes several implementations of <span class="caps">VSPL</span> in different&nbsp;languages.</p>
</li>
<li>
<p><a href="https://people.inf.ethz.ch/wirth/FPGA-relatedWork/ComputerSystemDesign.pdf">Experiments in Computer System
  Design</a>
  is a walk through of an implementation of a Tiny Register Machine (<span class="caps">TRM</span>) in
  Verilog with serial communication, <span class="caps">DRAM</span> access and multiprocessing (Niklaus
  Wirth,&nbsp;2010).</p>
</li>
<li>
<p><a href="https://github.com/cksystemsteaching/selfie">Selfie</a> is an educational
  platform for teaching programming languages and runtime systems. It is based
  on a simplified <span class="caps">RISC</span>-V architecture and includes a self-contained self-hosting
  compiler for a subset of C, an emulator, a hypervisor and a small standard
  library for the language. These tools are implemented in a single file (~12K
  lines of&nbsp;code).</p>
</li>
<li>
<p><a href="https://github.com/eliben/luz-cpu">Luz <span class="caps">CPU</span></a>, a simulator, assembler and
  linker for the Luz processor architecture written by Eli&nbsp;Bendersky.</p>
</li>
<li>
<p><a href="https://www.bigmessowires.com/nibbler/">Nibbler 4 Bit <span class="caps">CPU</span></a> is a complete
  description of a processor that has been implemented in discreet logic&nbsp;chips.</p>
</li>
<li>
<p><a href="https://imihajlov.tk/blog/posts/ccpu/">Discrete logic <span class="caps">IC</span> <span class="caps">CPU</span></a> us an
  architecture, discrete-logic implementation and basic tooling including a
  programming&nbsp;language.</p>
</li>
</ul>
<h2>Further reading <a name="further-reading" class="anchor"></a></h2>
<ul>
<li>
<p><a href="http://www.gamezero.com/team-0/articles/math_magic/micro/">Processor Design: An
  Introduction</a> a
  ground-up explanation of how processors&nbsp;work.</p>
</li>
<li>
<p><a href="https://releases.llvm.org/9.0.0/docs/tutorial/LangImpl01.html"><span class="caps">LLVM</span> Kaleidoscope
  Tutorial</a>
  which walks through an implementation of a simple programming language using
  <span class="caps">LLVM</span> as a backend for code generation and just-in-time&nbsp;compilation.</p>
</li>
</ul>
  </div>
  <div class="article-footer">
    <p>Please get in touch (mail @ this domain) with any
    comments, corrections or suggestions.</p>
  </div>
  </div>
  </main>

  <hr>
  <footer class="text-muted">
    <div class="container">
      <div class="small">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          <img alt="Creative Commons Licence" style="border-width:0"
               src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
        </a>
        <br>
        Unless otherwise noted, all content is freely available under a
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          Creative Commons Attribution 4.0 International License</a>.<br>
        The views expressed on this website are the authorâs personal views and should not be
        attributed to any other person, including that of their employer.<br>
        <br>
        Subscribe: <a href="https://jameswhanlon.com/reeds/atom.xml">Atom</a> /
        <a href="https://jameswhanlon.com/reeds/rss.xml">RSS</a>
      </div>
    </div>
  </footer>
  <script>
    function toggleMode(x) {
      // Toggle the colour mode in Bootstrap.
      if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
        document.documentElement.setAttribute('data-bs-theme','light')
      }
      else {
        document.documentElement.setAttribute('data-bs-theme','dark')
      }
      // Toggle the light/dark icon.
      x.firstElementChild.classList.toggle('bi-brightness-high-fill');
      x.firstElementChild.classList.toggle('bi-moon-fill');
      // Toggle the Pygments style.
      var elem = document.getElementById('pygments-style');
      if (elem.getAttribute('href') == './theme/css/pygments-dark.css') {
        elem.setAttribute('href', './theme/css/pygments.css');
      } else {
        elem.setAttribute('href', './theme/css/pygments-dark.css');
      }
    }
  </script>
</body>
</html>