<!DOCTYPE html>
<!-- Make light mode the default for articles since this works better with
    images with a white background and code highlighting. -->
<html lang="en" data-bs-theme=light>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="James W. Hanlon">
  <title>Building a PythonÂ processor</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./theme/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./theme/images/favicon-16x16.png">
  <!-- Default Pygments style -->
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" id="pygments-style"/>
  <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
  <link href="https://jameswhanlon.com/reeds/atom.xml"
        type="application/atom+xml" rel="alternate"
        title="James W. Hanlon Atom Feed" />
  <link href="https://jameswhanlon.com/reeds/rss.xml"
        type="application/rss+xml" rel="alternate"
        title="James W. Hanlon RSS Feed" />
  <!-- MathJax -->
  <script>
  MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
              svg: { fontCache: 'global' } };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>
  <script src="./theme/js/bundle.js"></script>
  <script data-goatcounter="https://jameswhanlon.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</head>
<body>
  <header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0 text-uppercase">
          <li class="nav-item">
              <a class="nav-link" href="/index.html">notes</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/projects.html">projects</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive.html">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about.html">about</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/links.html">links</a>
          </li>
        </ul>
        <a class="navbar-brand" href="#">James W. Hanlon</a>
        <button class="btn btn-secondary" type="button" onclick="toggleMode(this)">
          <!-- Initial button state -->
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </div>
  </nav>
  </header>

  <main class="flex-shrink-0">
  <div class="container">
  <h1>
    Building a Python&nbsp;processor
  </h1>
  <div class="lead">
    <time class="published" datetime="2023-06-27T00:00:00+02:00">
      27 Jun 2023
    </time><br>
      <span class="article-tag small"><a href="/tag/computing.html">computing</a></span>
      <span class="article-tag small"><a href="/tag/computer-architecture.html">computer-architecture</a></span>
  </div>
  <div class="article-body">
    <p>I have recently spent some time thinking about how hardware can be architected
and optimised to better support high-level dynamic languages such as Python and
JavaScript. There appears to be a significant gap between the way processors
and memory systems are built, which is to prioritise performance,  and the
characteristics of dynamic-language workloads, which prioritise ease of use. I
argue that dynamic languages are setting the direction of travel in the way we
use computers and this gap presents a huge opportunity for new hardware&nbsp;innovation.</p>
<h3>Table of&nbsp;contents</h3>
<ol>
<li><a href="#dynamic-languages">Dymamic&nbsp;languages</a></li>
<li><a href="#py-ai">Python and <span class="caps">AI</span></a></li>
<li><a href="#py-perf">Python&nbsp;performance</a></li>
<li><a href="#py-hw-impacts">Hardware impacts on Python&nbsp;performance</a></li>
<li><a href="#py-hw-support">Hardware support for&nbsp;Python</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
<li><a href="#related-links">Related&nbsp;links</a></li>
</ol>
<h2>Dynamic languages <a name="dynamic-languages" class="anchor"></a></h2>
<p>According to <a href="https://survey.stackoverflow.co/2023/#technology-most-popular-technologies">Stack Overflow&#8217;s 2023 developer survey</a>, JavaScript
has now been the most commonly-used language for the last 11 years and Python
has become the third most commonly-used language amongst all developers and the
first amongst non-professional developers and those learning to code. Nestled
amongst the most common languages are also TypeScript (a variant of
JavaScript), C#, <span class="caps">PHP</span>, Lua and Ruby. Applications of these languages are wide
ranging and varied, across all aspects of industry, science, business and&nbsp;government.</p>
<p>Dynamic languages have become popular because they are easy to use when
compared with their statically-compiled counterparts. There are many aspects of
the languages that <a href="https://erik-engheim.medium.com/the-many-advantages-of-dynamic-languages-267d08f4c7">contribute to this</a>, such as dynamic
typing, high-level features, no requirement for a compilation step to produce
an executable format (leading to rapid iteration times), portability between
platforms, powerful debugging due to runtime introspection, integration with
editors and IDEs and natural support for metaprogramming. Ease of use improves
programmer productivity and widens participation to non-professionals and those
without expertise in low-level programming. These benefits are also a critical
factor in the development of new application areas and technologies such as <span class="caps">AI</span>,
where research and practice moves rapidly and participation across academia and
industry is&nbsp;broad.</p>
<p>The cost of these benefits when compared with compiled languages is a runtime
performance overhead due to the additional work the language implementation
must do, for example to resolve names and types. The overhead depends on the
workload, but is often in the realms of tens to hundreds of times slower. The
evidence in the use of dynamic languages however is proof that this performance
overhead is acceptable price to pay for their benefits. Having said this, there
are ongoing substantial efforts to close the gap by optimising the language
implementations and compilation strategies. As far as I can see, this effort
has not extended to optimisation of the underlying&nbsp;hardware.</p>
<h2>Python and <span class="caps">AI</span> <a name="py-ai" class="anchor"></a></h2>
<p>In this remainder of this note I will focus on Python and its application to
<span class="caps">AI</span>, a domain that is significant enough to cause the development of new
computer hardware and rapid adoption of new process, integration and packaging&nbsp;technologies.</p>
<p>Python has established itself as the main programming language in <span class="caps">AI</span>, and this
is due to ease-of-use considerations. Programming in <span class="caps">AI</span> is typically done using
<em>frameworks</em>, meaning a library that provides facilities to express a
computation that is compiled and run within the program, rather than expressing
the computation directly in the programming language. TensorFlow and PyTorch
are two pre-eminent examples, but with PyTorch having <a href="https://www.semianalysis.com/p/nvidiaopenaitritonpytorch">taken the
lead</a> in becoming the most widely-used framework. TensorFlow
established itself early with support from Google, but it has lost its
dominance to PyTorch because PyTorch was easier to use and more flexible. It
was thus more widely adopted and more quickly applied to new application&nbsp;areas.</p>
<p>PyTorch&#8217;s <a href="https://pytorch.org/docs/stable/community/design.html">first design principle</a> is <em>usability over
performance</em> which clearly indicates ease of use is the driving force in <span class="caps">AI</span>
model development and deployment. PyTorch&#8217;s third design principle is <em>Python
first</em> meaning that working in Python natively (using the features of the
language) provides the best experience and results for users, rather than
deferring to optimised compiled-language libraries. PyTorch&#8217;s primacy and clear
prioritisation of ease of use indicates the direction of travel: that Python
will continue to become a first-class citizen in <span class="caps">AI</span> programming and so its
performance will be increasingly under&nbsp;scrutiny.</p>
<p>Since around 2012, <span class="caps">AI</span> has undergone a renaissance by scaling the performance of
deep neural networks with GPUs. Looking forward, there are many ways in which <span class="caps">AI</span>
models are expected to develop, requiring programming techniques and hardware to
develop to provide these capabilities&nbsp;too:</p>
<ul>
<li>
<p><strong>Model size</strong> is growing and will continue to grow. Although <span class="caps">GPT</span>-3 has 175
  bn parameters, there are an estimated 86 bn neurons in the human brain and an
  order-of 100 tn parameters (albeit encoded using analog mechanisms). It is
  likely that sparsity will increasingly be required to train and access these
  models&nbsp;efficiently.</p>
</li>
<li>
<p><strong>Conditional sparsity</strong> through conditionality in the structure of a
  network, eg routing of activity based on the data. In a dense network, every
  input interacts with every weight, but our brains don&#8217;t fire all neurons in
  response to every stimulus, and <strong>unconditional sparsity</strong> that is not
  dependent on the input, such as from pruning of&nbsp;connections.</p>
</li>
<li>
<p><strong>Symbolic representations</strong>. Symbolic <span class="caps">AI</span> programs are based on creating
  explicit structures and behaviour rules. This approach was the dominant
  paradigm in <span class="caps">AI</span> from the 1950s up to the mid 1990s. It is however considered a
  complementary technique to deep learning, possibly reflecting <a href="https://aaai-2022.virtualchair.net/plenary_13.html">the fast and
  slow parts of the human cognitive system</a>. Examples are <a href="https://en.wikipedia.org/wiki/Decision_tree">decision
  trees</a> and <a href="https://en.wikipedia.org/wiki/Probably_approximately_correct_learning"><span class="caps">PAC</span> learning</a>.</p>
</li>
<li>
<p><strong>Composition</strong>. New models will be created from parts such as whole sub models,
  or other reusable components. This is the way any complex system is
  constructed, including our&nbsp;brains.</p>
</li>
</ul>
<h2>Python performance <a name="py-perf" class="anchor"></a></h2>
<p>Broadly, the performance of Python programs can be improved at three&nbsp;levels:</p>
<ol>
<li>Optimising the&nbsp;application.</li>
<li>Optimising the language&nbsp;implementation.</li>
<li>Optimising the&nbsp;hardware.</li>
</ol>
<p>The work in <em>Quantitative Overhead Analysis for Python</em> [1] provides a detailed
analysis of overheads in CPython. <sup id="fnref:python-overheads"><a class="footnote-ref" href="#fn:python-overheads">1</a></sup> The different types of
overhead are described in the following table, which is taken from the&nbsp;paper.</p>
<table class="table table-sm table-striped">
  <caption>Sources of performance overhead in Python, from [1].</caption>
  <thead>
    <tr>
      <th scope="col">Group</th>
      <th scope="col">Overhead category</th>
      <th scope="col">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr><td rowspan="4">Additional language features</td></tr>
    <tr><td>Error check</td><td>Check for overflow, out-of-bounds and other errors</td></tr>
    <tr><td>Garbage collection</td><td>Automatically freeing unused memory</td></tr>
    <tr><td>Rich flow control</td><td>Support for more condition cases and control structures</td></tr>
    <tr><td rowspan="6">Dynamic language features</td></tr>
    <tr><td>Type check</td><td>Checking variable type to determine operation</td></tr>
    <tr><td>Boxing/unboxing</td><td>Wrapping or unwrapping integer or float types</td></tr>
    <tr><td>Name resolution</td><td>Looking up variable in a map</td></tr>
    <tr><td>Function resolution</td><td>Dereferencing function pointers to perform an operation</td></tr>
    <tr><td>Function setup/cleanup</td><td>Setting up for a function call and cleaning up when finished</td></tr>
    <tr><td rowspan="7">Interpreter operations</td></tr>
    <tr><td>Dispatch</td><td>Reading and decoding bytecode instruction</td></tr>
    <tr><td>Stack</td><td>Reading, writing, and managing <span class="caps">VM</span> stack</td></tr>
    <tr><td>Const load</td><td>Reading constants</td></tr>
    <tr><td>Object allocation</td><td>Inefficient deallocation followed by allocation of objects</td></tr>
    <tr><td>Reg transfer</td><td>Calculating address of <span class="caps">VM</span> storage</td></tr>
    <tr><td>C function call</td><td>Following the C calling convention in the interpreter</td></tr>
  </tbody>
</table>

<p>The following charts (also taken from the paper) show the proportions are given
as a percentage of total execution time, based on the measured execution of a
set of benchmarks. On average, 64.9% of overall execution time is overhead, and
the remaining 35.1% is used for the execution of the program. Of the language
features, name resolution and function setup/cleanup dominate. Of the
interpreter operations, dispatch (reading bytecode and executing the correct
operations) and C function calls&nbsp;dominate.</p>
<div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/measured-overheads.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/measured-overheads_1000x1000.png" alt="Python overheads measured in various benchmarks, from [1].">
  </a>
  <figcaption class="figure-caption text-left">Python overheads measured in various benchmarks, from [1].</figcaption>
</figure>
</div>

<p>There has been significant work on tackling (2) the language implementation.
Prominent examples include:
<a href="https://www.pypy.org">PyPy</a>, an alternative <a href="https://doc.pypy.org/en/latest/interpreter-optimizations.html">optimised</a> implementation written in
Python that includes a just in-time (<span class="caps">JIT</span>) compiler to dynamically optimise
common code paths;
<a href="https://github.com/facebookincubator/cinder">Cinder</a> is Meta&#8217;s internal performance-optimised version of
CPython that includes various performance optimisations and a per-method <span class="caps">JIT</span>;
<a href="https://cython.org">Cython</a> translates Python to C/C++ for static compilation and
execution in the CPython runtime environment;
<a href="https://nuitka.net">Nuitka</a> is similar to Cython, as a compiler from Python to C,
using the CPython interpreter as a library;
And not forgetting CPython itself has an active project led by Microsoft and
Guido van Rossum called <a href="https://github.com/faster-cpython/ideas">Faster CPython</a> to explore
performance optimisations.
Approximately, these approaches achieve speedups of up to an order of magnitude
when compared to the standard CPython&nbsp;implementation.</p>
<p>Where the previous examples optimise Python as a general-purpose language, some
approaches such as <a href="https://docs.exaloop.io/codon">Codon</a>, <a href="https://numba.pydata.org/">Numba</a> and <a href="https://triton-lang.org">Triton</a> compile
subsets of Python into machine code for host or accelerator devices,
eliminating the runtime overhead altogether. These approaches can achieve
speedups of the order of 100 times for serial execution. They focus however
on accelerating numerical computations and therefore sidestep the difficulties
of statically-compiling dynamic features such as naming, large integers and
data structures, which are much more&nbsp;challenging.</p>
<p>Within the scope of (1) optimising the application, a significant issue
preventing the use of parallelism is Python&#8217;s <a href="https://wiki.python.org/moin/GlobalInterpreterLock">Global Interpreter Lock
(<span class="caps">GIL</span>)</a>. This lock allows only one thread to execute the interpreter at
once, which was done originally to make the counting of object references
simpler. It is possible to work around the constraints imposed by the <span class="caps">GIL</span>, such
as with&nbsp;the <code>multiprocessing</code> module but this makes it difficult to express
different types of parallelism and creates an ease-of-use problem. A
<a href="https://peps.python.org/pep-0703/"><span class="caps">PEP</span></a> submitted by a PyTorch developer makes the case for removing the
<span class="caps">GIL</span>, outlining motivating examples in scientific and numerical computing, and
tasks using Python for coordination and communication. A decision on adoption
of this <span class="caps">PEP</span> is yet to be made but a <a href="https://github.com/colesbury/nogil-3.12">reference implementation</a> is&nbsp;available.</p>
<p>There are various sources of overhead in the execution of a Python program that
can contribute to orders-of-magnitude slower runtime compared to a compiled
program. Strategies to reduce this overhead are in optimising the sources of
overhead directly by improving compilation strategies, improving runtime
strategies (such as caching of accesses or performing <span class="caps">JIT</span> compilation to
machine code of frequent code paths), statically compiling Python code to C
code including inline calls to the interpreter, and, for restricted subsets of
Python, statically compiling Python code to machine code without the
interpreter. These approaches are all within the software domain, so it is
interesting to consider in what ways computer hardware could be optimised to
further reduce the runtime overheads in Python&nbsp;programs.</p>
<h2>Hardware impacts on Python performance <a name="py-hw-impacts" class="anchor"></a></h2>
<p>The main findings from the microarchitecture investigation in [1] summarised
below provide a useful basis for understanding how Python is limited by current
computer hardware. The study is based on a range of benchmarks run with CPython
and PyPy with and without <span class="caps">JIT</span>.</p>
<ul>
<li>
<p><strong><span class="caps">ILP</span></strong>. Both CPython and PyPy exhibit low instruction-level parallelism.
  This suggests that choosing a deeply-pipelined out-of-order core may not
  provide good tradeoff between silicon area and performance. A simpler, in-order
  core may instead be a better choice, particularly when building a parallel
  processor with many&nbsp;cores.</p>
</li>
<li>
<p><strong>Working memory</strong>. Across all the benchmarks, large caches do not provide a
  performance benefit, implying that working sets tend to be relatively&nbsp;small.</p>
</li>
<li>
<p><strong>Nursery sizing</strong>. A critical factor related to working memory is an area
  used for the allocation for short-term objects called a <em>nursery</em>. When the
  nursery does not fit in cache, performance is impacted due to cache thrashing.
  However, there are two things to consider: reducing the nursery size will
  increase garbage-collection overheads and the optimal nursery size is dependent
  on the&nbsp;application.</p>
</li>
<li>
<p><strong><span class="caps">JIT</span></strong>. When <span class="caps">JIT</span> compilation is used, the memory system is put under more
  pressure, so although the number of instructions executed reduces, the
  latency of memory operations increases due to cache line misses. This implies
  the working memory increases and so accordingly the overhead of garbage
  collection also&nbsp;increases.</p>
</li>
</ul>
<p>It is clear from these findings that optimising the memory system will yield a
more significant performance improvement than optimising the processor
microarchitecture and instruction set design (as is typically the focus of new
processor designs). Orthogonal to optimisations in the memory system, providing
more execution parallelism at the process level is the only other way to
significantly scale performance. This gives us the basis for a new Python&nbsp;processor.</p>
<h2>Hardware support for Python <a name="py-hw-support" class="anchor"></a></h2>
<p>This section presents some rough ideas on what new computer hardware might
look like that optimises the execution of Python (or indeed other dynamic&nbsp;languages).</p>
<h3>System&nbsp;architecture</h3>
<p>The most straightforward way to deploy a new processor chip is as an
<em>accelerator</em> to a conventional <em>host</em> processor connected via PCIe. The host
processor can then offload parts or all of the Python workload to the
accelerator for improved performance. The following diagrams show two ways that
this could work: one where the host runs the Python interpreter and offloads
parts of the Python program (similar to the way <em>Eager Mode</em> works in PyTorch
and TensorFlow); the other where the accelerator runs the Python interpreter
and communicates to the host via a standard set of system calls. The first
scenario means that execution can fall back onto the host if the Python code
was not supported by the accelerator, thereby allowing the design of the
accelerator to be simpler. However, managing the communication of Python
objects over this boundary is complicated and potentially a significant
overhead. In the second scenario, the whole Python program is executed by the
interpreter running on the accelerator. This simplifies the interface between
the two devices, which would only need to provide basic system calls to the&nbsp;interpreter.</p>
<div class="container">
  <div class="row align-items-center">
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/offload-model-fine.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/offload-model-fine_1000x1000.png" alt="Fine-grained offload">
  </a>
  <figcaption class="figure-caption text-left">Fine-grained offload</figcaption>
</figure>
</div>

    </div>
    <div class="col">
    <div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/offload-model-coarse.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/offload-model-coarse_1000x1000.png" alt="Coarse-grained offload">
  </a>
  <figcaption class="figure-caption text-left">Coarse-grained offload</figcaption>
</figure>
</div>

    </div>
  </div>
</div>

<p>At a system level, an accelerator device for Python might be integrated between
the host processor and other accelerators (typically GPUs in data-centre-type
deployments) since Python will be responsible for coordinating offload of
computations. Access to external memory can either be to <span class="caps">DRAM</span> via the host or
on <span class="caps">DRAM</span> integrated with the device. The latter has the benefit of being able to
supply lower latency and higher bandwidth to the&nbsp;memories.</p>
<div class="text-center">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/accelerator.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/accelerator_1000x1000.png" alt="No alt text">
  </a>
</div>

<h3>Core&nbsp;architecture</h3>
<p>At the core level, it makes a lot of sense to use <span class="caps">RISC</span>-V as the base
architecture because it is a general-purpose <span class="caps">ISA</span> that is open and easily
extensible. As previously noted, the <span class="caps">RISC</span>-V microarchitecture can be kept
simple because interpreting Python is not heavily dependent on <span class="caps">ILP</span>. The
complexity of the microarchitecture depends on the best tradeoff between
sequential and parallel performance, which in turn depends on the workload. <span class="caps">AI</span>
for example will be weighted towards highly-parallel execution, so is better
suited to a large number of simple processor cores. Extensions to the core can
be added to provide optimised support for specific operations (eg
floating-point arithmetic and for matrix multiplication), support for
concurrency (threading, synchronisation, communication etc) or control over the
memory&nbsp;hierarchy.</p>
<h3>Memory&nbsp;system</h3>
<p>One way to improve the way memory is managed is to bring some level of control
of the cache to the processor. In the following diagram, A <span class="caps">RISC</span>-V core has
extensions that allows it to control a &#8216;smart cache&#8217;. Such a system could
enable aggressive caching of computations that are frequently recomputed, such
as in the processes of name and function resolution, or from calling a function
with the same arguments, which account for a substantial portion of the
language overhead. A motivating example is caching of the&nbsp;C <code>strlen</code> function
that is used frequently by the Python interpreter in name resolution. A
difficulty in caching this function entirely in software is that a full string
comparison is required to determine whether to invalidate the cache or not, and
this is roughly as expensive&nbsp;as <code>strlen</code>. A hardware caching scheme could be
implemented more simply by snooping memory writes and invalidating the cache
entry if any part of the string has changed. To support this, hardware
extensions would be required to place items in the cache, retrieve items in the
cache, monitor ranges of memory and invalidate items in monitored&nbsp;ranges.</p>
<div class="text-center">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/smart-cache.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/smart-cache_1000x1000.png" alt="No alt text">
  </a>
</div>

<p>Another memory-system optimisation is to provide garbage collection (<span class="caps">GC</span>) as a
hardware-managed function. <span class="caps">GC</span> is a technique that has been studied for decades,
including in hardware: it was first introduced in Lisp in the 1950s and
appeared as a hardware extension in the 1981 <a href="https://en.wikipedia.org/wiki/Intel_iAPX_432#Garbage_collection">Intel iAPX 432</a> (see
[4] for a literature review of hardware <span class="caps">GC</span> techniques and implementations).
Surprisingly, hardware <span class="caps">GC</span> has never caught on and this is certainly related to
the <a href="https://www.quora.com/Why-dont-modern-CPUs-offer-hardware-assisted-garbage-collection-and-memory-allocation">challenges</a> of a performant solution requiring integration
across many levels of abstraction: microarchitecture, architecture, tooling,
operating systems and languages. However, it seems that this precedent should
be challenged given that <span class="caps">GC</span> is central to the way dynamic languages&nbsp;work.</p>
<h3>Scaling the number of&nbsp;cores</h3>
<p>Building a system with multiple processing cores can be done in a conventional
way by sharing access to higher levels of cache and adding a coherency
mechanism for lower-level private caches, but this does not scale well past a
few tens or hundreds of cores due to the overheads of maintaining coherency. A
different and more radical approach is to use a distributed-memory architecture
where each core has a private memory and communication between cores or to
external <span class="caps">DRAM</span> is performed explicitly using messages. The major benefit of such
an architecture is that is scalable to large numbers of cores, providing more
performance from parallelism, and that processor-memory pairs can flexibly be
used as units of memory or processing dependent on the application. This
approach generalises the concept of a programmable cache hierarchy by using
processor-memory pairs as units of memory with the processor providing access
logic and building arbitrary caching schemes in software, dependent on the
characteristics of the workload. I have previously written about this idea in
my work on <a href="files/emulation.pdf">emulating large memories</a>.
Alternatively, processor-memory pairs can be turned over to processing and used
to execute parts of an application in parallel, a great example of which would
be running one or several <span class="caps">JIT</span> compiler processes concurrently with the&nbsp;application.</p>
<p>The following diagram sketches how such a machine might be built. The main
building blocks are a processor-memory <em>tile</em> and a <em>router</em>. The tile includes
communication facilities, allowing it to communicate to all other tiles in the
system and to off-chip communication interfaces via routers. The arrangement of
routers and tiles is flexible but the routers have enough links that
high-dimensional topologies can be created to provide communication with
bounded latency and throughput, which is essential for a general-purpose
machine. The operation of the communications fabric could be dynamic allocated
with packet switching, or statically allocated with circuit switching. Special
packet types can be used for accessing external memory or other off-chip <span class="caps">IO</span>, or
for implementing shared-memory operations such as direct access to remote tile
memories. Collective operations such as scatters and gathers are likely to be
frequently used, so could be optimised with supporting hardware in the tile and
routers. These are the essential ingredients of a  general-purpose fine-grained
parallel machine. I have previously outlined a similar kind of machine in my
<a href="/scalable-abstractions-for-general-purpose-parallel-computation.html">PhD thesis</a>, and I intend to post a note with a revised and fuller
description at some point&nbsp;soon.</p>
<div class="text-center">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/python-processor/parallel-microarchitecture-top.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/parallel-microarchitecture-top_1000x1000.png" alt="No alt text">
  </a>
</div>

<h2>Summary <a name="summary" class="anchor"></a></h2>
<p>This note makes the argument that ease of use the critical factor in the
development of new application areas and the adoption of new computer hardware.
Ease of use has in many regards won as the most important factor in software
and programming, but new computer hardware prioritises performance. Closing
this gap would mean that rapidly-developing application areas such as <span class="caps">AI</span> would
benefit by moving the boundary away from optimised low-level libraries, making
fuller use of languages such as Python. For computer designers, there is a huge
opportunity for new architectural innovations that support a radically
different workload from conventional low-level compiled languages. Contrary to
conventional wisdom, hardware is easier to innovate rapidly and it is software
that bears the weight of&nbsp;legacy.</p>
<h2>Acknowledgements <a name="acknowledgements" class="anchor"></a></h2>
<p>The hardware ideas in this note were developed in conversations with <a href="http://www.jpallister.com">James
Pallister</a>. Closely related to some of the ideas explored is a new
<span class="caps">UK</span> startup <a href="https://www.vypercore.com">VyperCore</a> co-founded by <a href="https://ednutting.com">Ed Nutting</a> who are
building a <span class="caps">RISC</span>-V-based processor that includes facilities for hardware memory
allocation and <span class="caps">GC</span> for performance and&nbsp;safety.</p>
<h2>References <a name="references" class="anchor"></a></h2>
<ol>
<li>
<p>Mohamed Ismail and G. Edward Suh, <em>Quantitative Overhead Analysis for
   Python</em>, 2018 <span class="caps">IEEE</span> International Symposium on Workload Characterization
   (<span class="caps">IISWC</span>). [<a href="https://ieeexplore.ieee.org/document/8573512"><span class="caps">IEEE</span></a>, <a href="https://www.cs.ucsb.edu/sites/default/files/documents/2010-14.pdf"><span class="caps">PDF</span></a>]</p>
</li>
<li>
<p>Nagy Mostafa, Chandra Krintz, Calin Cascaval, David Edelsohn, Priya
   Nagpurkar, Peng Wu, <em>Understanding the Potential of Interpreter-based
   Optimizations for Python</em>. <span class="caps">UCSB</span> Technical Report #2010-14 August, 2010.
   [<a href="https://cs.ucsb.edu/research/tech-reports/2010-14"><span class="caps">PDF</span></a>]</p>
</li>
<li>
<p>GergÃ¶ Barany, <em>Python Interpreter Performance Deconstructed</em>,
   Proceedings of the Workshop on Dynamic Languages and Applications, June 2014.
   [<a href="https://dl.acm.org/doi/10.1145/2617548.2617552"><span class="caps">ACM</span></a>, <a href="https://www.cs.ucsb.edu/sites/default/files/documents/2010-14.pdf"><span class="caps">PDF</span></a>]</p>
</li>
<li>
<p>Andres Amaya Garcia, Integrated hardware garbage collection for real-time
   embedded systems, PhD thesis, University of Bristol 2021.
   [<a href="https://research-information.bris.ac.uk/en/studentTheses/integrated-hardware-garbage-collection-for-real-time-embedded-sys">University of Bristol</a>, <a href="https://research-information.bris.ac.uk/files/298185781/Final_Copy_2021_09_28_Amaya_Garcia_A_PhD.pdf"><span class="caps">PDF</span></a>]</p>
</li>
</ol>
<h2>Related links <a name="related-links" class="anchor"></a></h2>
<ul>
<li><a href="http://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/">Why Python is Slow: Looking Under the Hood</a>, Pythonic Perambulations blog&nbsp;(2014).</li>
<li><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/accelerating-python-today.html#gs.35k6hi">Accelerating Python Today</a>, Intel technical note, James&nbsp;Reinders.</li>
</ul>
<div class="footnote">
<hr>
<ol>
<li id="fn:python-overheads">
<p>See [2] and [3] for other similar analyses that [1] builds on.&#160;<a class="footnote-backref" href="#fnref:python-overheads" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="article-footer">
    <p>Please get in touch (mail @ this domain) with any
    comments, corrections or suggestions.</p>
  </div>
  </div>
  </main>

  <hr>
  <footer class="text-muted">
    <div class="container">
      <div class="small">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          <img alt="Creative Commons Licence" style="border-width:0"
               src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
        </a>
        <br>
        Unless otherwise noted, all content is freely available under a
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          Creative Commons Attribution 4.0 International License</a>.<br>
        The views expressed on this website are the authorâs personal views and should not be
        attributed to any other person, including that of their employer.<br>
        <br>
        Subscribe: <a href="https://jameswhanlon.com/reeds/atom.xml">Atom</a> /
        <a href="https://jameswhanlon.com/reeds/rss.xml">RSS</a>
      </div>
    </div>
  </footer>
  <script>
    function toggleMode(x) {
      // Toggle the colour mode in Bootstrap.
      if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
        document.documentElement.setAttribute('data-bs-theme','light')
      }
      else {
        document.documentElement.setAttribute('data-bs-theme','dark')
      }
      // Toggle the light/dark icon.
      x.firstElementChild.classList.toggle('bi-brightness-high-fill');
      x.firstElementChild.classList.toggle('bi-moon-fill');
      // Toggle the Pygments style.
      var elem = document.getElementById('pygments-style');
      if (elem.getAttribute('href') == './theme/css/pygments-dark.css') {
        elem.setAttribute('href', './theme/css/pygments.css');
      } else {
        elem.setAttribute('href', './theme/css/pygments-dark.css');
      }
    }
  </script>
</body>
</html>