<!DOCTYPE html>
<!-- Make light mode the default for articles since this works better with
    images with a white background and code highlighting. -->
<html lang="en" data-bs-theme=light>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="James W. Hanlon">
  <title>The hardware pseudorandom number generator of the Graphcore IPU</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./theme/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./theme/images/favicon-16x16.png">
  <!-- Default Pygments style -->
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" id="pygments-style"/>
  <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
  <link href="https://jameswhanlon.com/reeds/atom.xml"
        type="application/atom+xml" rel="alternate"
        title="James W. Hanlon Atom Feed" />
  <link href="https://jameswhanlon.com/reeds/rss.xml"
        type="application/rss+xml" rel="alternate"
        title="James W. Hanlon RSS Feed" />
  <!-- MathJax -->
  <script>
  MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
              svg: { fontCache: 'global' } };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>
  <script src="./theme/js/bundle.js"></script>
  <script data-goatcounter="https://jameswhanlon.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</head>
<body>
  <header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0 text-uppercase">
          <li class="nav-item">
              <a class="nav-link" href="/index.html">notes</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/projects.html">projects</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive.html">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about.html">about</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/links.html">links</a>
          </li>
        </ul>
        <a class="navbar-brand" href="#">James W. Hanlon</a>
        <button class="btn btn-secondary" type="button" onclick="toggleMode(this)">
          <!-- Initial button state -->
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </div>
  </nav>
  </header>

  <main class="flex-shrink-0">
  <div class="container">
  <h1>
    The hardware pseudorandom number generator of the Graphcore <span class="caps">IPU</span>
  </h1>
  <div class="lead">
    <time class="published" datetime="2022-09-21T00:00:00+02:00">
      21 Sep 2022
    </time><br>
      <span class="article-tag small"><a href="/tag/computing.html">computing</a></span>
      <span class="article-tag small"><a href="/tag/PRNGs.html">PRNGs</a></span>
  </div>
  <div class="article-body">
    <p>This note is a short summary of my <a href="https://ieeexplore.ieee.org/document/9875973"><span class="caps">IEEE</span> Transactions on Computers journal
paper</a> and was originally written
to appear on the Graphcore&nbsp;blog.</p>
<p>The Graphcore <span class="caps">IPU</span> contains a novel pseudorandom number generator (<span class="caps">PRNG</span>) that
was designed to produce high-quality statistical randomness, whist also being
cheap to implement in hardware. Having an efficient hardware <span class="caps">RNG</span> means
randomness can be used frequently: the IPUs generator can produce 64-bits of
unique randomness from all of its 1,216 tiles every clock cycle. This, for
example, makes it possible to perform on-the-fly stochastic rounding of
low-precision floating-point&nbsp;numbers.</p>
<p>We needed a new <span class="caps">PRNG</span> because typical state-of-the-art generators are designed
to be performant when run as software routines, but operations that are cheap
to execute on a processor may not be cheap to implement in hardware as is the
case for multiplication or division. Our&nbsp;generator <code>xoroshiro128aox</code> is based
on <a href="https://vigna.di.unimi.it/">Sebastiano&nbsp;Vigna’s</a> <code>xoroshiro128</code>
linear-feedback shift register (<span class="caps">LFSR</span>), which is attractive because it uses 128
bits of state and is cheap to implement in hardware. The <span class="caps">LFSR</span> operates by
performing <span class="caps">XOR</span> and fixed-distance shift and rotate operations on the state.
Following Vigna’s approach of adding a function to ‘scramble’ the <span class="caps">LFSR</span> state,
we have devised a function consisting of <span class="caps">AND</span>, <span class="caps">OR</span> and <span class="caps">XOR</span> operations (called <span class="caps">AOX</span>
for short). An C implementation&nbsp;of <code>xoroshiro128aox</code> is as&nbsp;follows:</p>
<div class="highlight"><pre><span></span><code><span class="kt">uint64_t</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span><span class="w"> </span><span class="c1">// State vectors</span>

<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">rotl</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">64</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">k</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">sx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Calculate the result, the &#39;AOX&#39; step.</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">sa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s0</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<span class="w">  </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sx</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="n">rotl</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rotl</span><span class="p">(</span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// xoroshiro128 state update</span>
<span class="w">  </span><span class="n">s0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotl</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="mi">55</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">sx</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="p">(</span><span class="n">sx</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">14</span><span class="p">);</span>
<span class="w">  </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotl</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span><span class="w"> </span><span class="mi">36</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>To determine that this new <span class="caps">PRNG</span> provides a good source of randomness, we took
the conventional approach of subjecting the generator to batteries of
statistical tests, that aim to detect correlations over large portions of the
generator’s output. Given that any <span class="caps">PRNG</span> is inherently non-random because they
produce numbers according to a fixed sequence, statistical testing is only as
good as the tests that they run, and their performance can only be judged on
their ability to distinguish existing good generators from bad ones. Indeed, a
novel statistical test could immediately raise the bar for all&nbsp;PRNGs.</p>
<p>Within the field of <span class="caps">PRNG</span> design,
<a href="http://simul.iro.umontreal.ca/testu01/tu01.html">TestU01’s</a> BigCrush battery
is accepted as the gold-standard statistical test, however it is not always
clear exactly what methodology has been used to obtain a pass/fail result. In
particular, the choice of initial state (the seed) is important because
different parts of a sequence may have different properties, and TestU01 has
known biases in the way it uses bits from a generator’s output. To mitigate
these issues, we run every generator from 100 unique seeds and supply six
permutations of the output bits. And as well as running TestU01, we also run
<a href="http://pracrand.sourceforge.net/">PractRand</a> and
<a href="http://gjrand.sourceforge.net/">Gjrand</a> with the same 100 seeds, which are the
two other most well-regarded test sets. This gives us a comprehensive testing
methodology that goes beyond the typical level of&nbsp;analysis.</p>
<p>To provide a point of comparison, we include the following&nbsp;PRNGs:</p>
<ul>
<li>
<p>32-bit Mersenne&nbsp;Twister, <code>mt32</code>, since it is one of the most widely used
    software PRNGs (although it has 19,937 bits of&nbsp;state!).</p>
</li>
<li>
<p><code>xoroshiro128+</code>, which is Vigna’s closest variant&nbsp;of <code>xoroshiro128</code>,
    using 64-bit addition to scramble 128-bit <span class="caps">LFSR</span>&nbsp;states.</p>
</li>
</ul>
<p>And to represent the current state-of-the-art 128-bit generators, we&nbsp;include:</p>
<ul>
<li>
<p><code>philox4x32-10</code>, a counter-based generator whose transition between states
    is a 128-bit increment and output scrambling function is 10 rounds of 32-bit
  multiplications and&nbsp;XORs.</p>
</li>
<li>
<p><code>pcg64</code>, a linear-congruential generator (<span class="caps">LCG</span>) that uses multiplication and
    addition by 128-bit constants for the state-transition function, and <span class="caps">XOR</span> and
  variable rotation operations to produce&nbsp;outputs.</p>
</li>
</ul>
<p>The table below summarises the TestU01 BigCrush results, where the six output
columns correspond to different permutations of the generators bits (eg 1 is
unchanged, 2 is swapping the most and least significant 32 bits) and the
numbers are total failures. Since a true random number generator has a
probability of failing, the expected number of failures can be calculated.
BigCrush runs 160 individual tests (and consumes approximately 1 <span class="caps">TB</span> of random
data), so in this case the expected number is 32. A generator is considered to
fail only when it fails on the same test over all seeds, which can be seen in
the entries highlighted in red. The Mersenne Twister consistently fails,
whereas xoroshiro128+ fails on a particular output permutation where the lower
32 bits are discarded (this is a known deficiency of the&nbsp;generator).</p>
<table class="table table-striped table-sm">
<thead>
  <th scope="col">Generator</th>
  <th scope="col">Output 1</th>
  <th scope="col">Output 2</th>
  <th scope="col">Output 3</th>
  <th scope="col">Output 4</th>
  <th scope="col">Output 5</th>
  <th scope="col">Output 6</th>
  <th scope="col">Total failures</th>
</thead>
<tbody>
<tr>
  <td><code>mt32</code></td>
  <td>236</td>
  <td>237</td>
  <td>233</td>
  <td>238</td>
  <td>246</td>
  <td>237</td>
  <td>1427</td>
</tr>
<tr>
  <td><code>pcg64</code></td>
  <td>34</td>
  <td>30</td>
  <td>38</td>
  <td>37</td>
  <td>38</td>
  <td>27</td>
  <td>204</td>
</tr>
<tr>
  <td><code>philox4x32-10</code></td>
  <td>33</td>
  <td>32</td>
  <td>32</td>
  <td>32</td>
  <td>28</td>
  <td>38</td>
  <td>195</td>
</tr>
<tr>
  <td><code>xoroshiro128+</code></td>
  <td>33</td>
  <td>29</td>
  <td>28</td>
  <td>40</td>
  <td>353</td>
  <td>42</td>
  <td>525</td>
</tr>
<tr>
  <td><code>xoroshiro128aox</code></td>
  <td>31</td>
  <td>32</td>
  <td>41</td>
  <td>30</td>
  <td>44</td>
  <td>32</td>
  <td>210</td>
</tr>
</tbody>
</table>

<p>The table below summarises the Gjrand results, which just runs 13 tests and by
default consumes approximately 10 <span class="caps">TB</span> of data. Unlike BigCrush and TestU01,
xoroshiro128aox fails Gjrand on both versions of its z9 test, which looks for
dependencies in the Hamming Weight of successive outputs. Although BigCrush and
PractRand include similar tests that analyse Hamming Weight dependencies, they
do not detect correlations. What this shows is that the scrambling of the
xoroshiro128 <span class="caps">LFSR</span>’s state serves to hide correlations due to the linear
operations only to an extent, and a particular test will be sensitive enough to
detect them. Given that BigCrush and PractRand did not, xoroshiro128aox
represents a significant improvement over xoroshiro128+, whilst still being
cheap to implement in hardware as we show in the next&nbsp;section.</p>
<table class="table table-striped table-sm">
<thead>
  <th scope="col">Generator</th>
  <th scope="col">Total failures</th>
</thead>
<tbody>
<tr>
  <td><code>mt32</code></td>
  <td>107</td>
</tr>
<tr>
  <td><code>pcg64</code></td>
  <td>15</td>
</tr>
<tr>
  <td><code>philox4x32-10</code></td>
  <td>7</td>
</tr>
<tr>
  <td><code>xoroshiro128+</code></td>
  <td>210</td>
</tr>
<tr>
  <td><code>xoroshiro128aox</code></td>
  <td>205</td>
</tr>
</tbody>
</table>

<p>To demonstrate that xoroshiro128aox is indeed cheap to implement in hardware,
we compare physical implementations of the generators (excluding Mersenne
Twister because of its considerable state size) after they have been fully
synthesised and placed and routed using Graphcore’s 7 nm cell library and a
target clock period of 1 GHz. The table below summarises the&nbsp;results.</p>
<table class="table table-striped table-sm">
<thead>
  <th scope="col">Generator</th>
  <th scope="col">Total cells (state update)</th>
  <th scope="col">Logic depth (state update)</th>
  <th scope="col">Total cells (output)</th>
  <th scope="col">Logic depth (output)</th>
  <th scope="col">Total cells</th>
</thead>
<tbody>
<tr>
  <td><code>xoroshiro128aox</code></td>
  <td>331 </td>
  <td>4   </td>
  <td>353 </td>
  <td>4   </td>
  <td>684 </td>
</tr>
<tr>
  <td><code>xoroshiro128+</code></td>
  <td>331 </td>
  <td>3   </td>
  <td>906 </td>
  <td>13  </td>
  <td>1237</td>
</tr>
<tr>
  <td><code>pcg64</code></td>
  <td>9564 </td>
  <td>26   </td>
  <td>658  </td>
  <td>7    </td>
  <td>10222</td>
</tr>
<tr>
  <td><code>philox4x32-10</code></td>
  <td>1003 </td>
  <td>13   </td>
  <td>29553</td>
  <td>89   </td>
  <td>30556</td>
</tr>
</tbody>
</table>

<p>Key takeaways from these results&nbsp;are:</p>
<ul>
<li>
<p>That <span class="caps">AOX</span> is approximately one third of the cost of a full 64-bit addition and
  the cheapest option overall by a factor of&nbsp;two.</p>
</li>
<li>
<p>For <code>pcg64</code> the cost is dominated by the 128-bit arithmetic for its state&nbsp;update.</p>
</li>
<li>
<p>For <code>philox4x32-10</code> the cost is dominated by the output function composed of 10
  stages of 32-bit&nbsp;arithmetic.</p>
</li>
</ul>
<p>The following are illustrations of the four <span class="caps">PRNG</span> circuit floorplans, which make
clear the differences in implementation complexity (left to&nbsp;right:
<code>xoroshiro128aox</code>, <code>xoroshiro128+</code>, <code>pcg64</code>, <code>philox4x32-10</code>):</p>
<table>
<tbody>
<tr>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/plus.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/plus_600x600.png" alt="xoroshiro128+">
  </a>
  <figcaption class="figure-caption text-left">xoroshiro128+</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/aox.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/aox_600x600.png" alt="xoroshiro128aox">
  </a>
  <figcaption class="figure-caption text-left">xoroshiro128aox</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/pcg64.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/pcg64_600x600.png" alt="pcg64">
  </a>
  <figcaption class="figure-caption text-left">pcg64</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/philox.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/philox_600x600.png" alt="philox4x32-10">
  </a>
  <figcaption class="figure-caption text-left">philox4x32-10</figcaption>
</figure>
</div>
</td>
</tr>
</table>

<p>And scaled to relative&nbsp;sizes:</p>
<!--
%          h      w         Scale
% plus     25.8   12.992    1
% aox      23.1   11.648    0.896551724
% pcg      63.9   32        2.463054187
% philox   115.8  57.984    4.463054187
-->
<table>
<tbody>
<tr>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/plus.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/plus_100x100.png" alt="xoroshiro128+">
  </a>
  <figcaption class="figure-caption text-left">xoroshiro128+</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/aox.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/aox_90x90.png" alt="xoroshiro128aox">
  </a>
  <figcaption class="figure-caption text-left">xoroshiro128aox</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/pcg64.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/pcg64_246x246.png" alt="pcg64">
  </a>
  <figcaption class="figure-caption text-left">pcg64</figcaption>
</figure>
</div>
</td>
  <td><div class="text-center">
<figure class="figure">
  <a href="https://jwh.ams3.digitaloceanspaces.com/homepage/prng-quality/philox.png" data-lightbox="all">
    <img class="figure-img img-fluid thumbnail" src="/thumbs/philox_446x446.png" alt="philox4x32-10">
  </a>
  <figcaption class="figure-caption text-left">philox4x32-10</figcaption>
</figure>
</div>
</td>
</tr>
</table>

<h2>Summary</h2>
<p>This note has provided an overview of the methodology and results of the
analysis we conducted into the statistical quality of our novel <span class="caps">PRNG</span>
<code>xoroshiro128aox</code>. This has established that our generator mitigates known
existing weaknesses&nbsp;of <code>xoroshiro128+</code> on which it is based, and delivers
comparable levels of statistical quality on the gold-standard BigCrush test set
as two contemporary fast PRNGs&nbsp;: <code>pcg64</code> and <code>philox4x32-10</code>. Extending
testing by using PractRand and Gjrand, we do eventually find that a weakness is
detectable by Gjrand. Since this is not systematic across the test suites, as
we have seen for the Mersenne Twister, we can&nbsp;consider <code>xoroshiro128aox</code> to
provide an excellent tradeoff between quality and implementation cost in&nbsp;hardware.</p>
<p>Full details of the investigation can be found in the <a href="https://arxiv.org/abs/2203.04058">preprint paper on
arXiv</a>, and the <a href="https://github.com/jameshanlon/prng-testing">source
code</a> for the experiments on&nbsp;GitHub.</p>
  </div>
  <div class="article-footer">
    <p>Please get in touch (mail @ this domain) with any
    comments, corrections or suggestions.</p>
  </div>
  </div>
  </main>

  <hr>
  <footer class="text-muted">
    <div class="container">
      <div class="small">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          <img alt="Creative Commons Licence" style="border-width:0"
               src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
        </a>
        <br>
        Unless otherwise noted, all content is freely available under a
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          Creative Commons Attribution 4.0 International License</a>.<br>
        The views expressed on this website are the author’s personal views and should not be
        attributed to any other person, including that of their employer.<br>
        <br>
        Subscribe: <a href="https://jameswhanlon.com/reeds/atom.xml">Atom</a> /
        <a href="https://jameswhanlon.com/reeds/rss.xml">RSS</a>
      </div>
    </div>
  </footer>
  <script>
    function toggleMode(x) {
      // Toggle the colour mode in Bootstrap.
      if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
        document.documentElement.setAttribute('data-bs-theme','light')
      }
      else {
        document.documentElement.setAttribute('data-bs-theme','dark')
      }
      // Toggle the light/dark icon.
      x.firstElementChild.classList.toggle('bi-brightness-high-fill');
      x.firstElementChild.classList.toggle('bi-moon-fill');
      // Toggle the Pygments style.
      var elem = document.getElementById('pygments-style');
      if (elem.getAttribute('href') == './theme/css/pygments-dark.css') {
        elem.setAttribute('href', './theme/css/pygments.css');
      } else {
        elem.setAttribute('href', './theme/css/pygments-dark.css');
      }
    }
  </script>
</body>
</html>