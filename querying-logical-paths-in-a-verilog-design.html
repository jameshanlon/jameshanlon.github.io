<!DOCTYPE html>
<!-- Make light mode the default for articles since this works better with
    images with a white background and code highlighting. -->
<html lang="en" data-bs-theme=light>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="James W. Hanlon">
  <title>Querying logical paths in a VerilogÂ design</title>
  <link rel="icon" type="image/png" sizes="32x32" href="./theme/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="./theme/images/favicon-16x16.png">
  <!-- Default Pygments style -->
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css" id="pygments-style"/>
  <link rel="stylesheet" type="text/css" href="./theme/css/main.css"/>
  <link href="https://jameswhanlon.com/reeds/atom.xml"
        type="application/atom+xml" rel="alternate"
        title="James W. Hanlon Atom Feed" />
  <link href="https://jameswhanlon.com/reeds/rss.xml"
        type="application/rss+xml" rel="alternate"
        title="James W. Hanlon RSS Feed" />
  <!-- MathJax -->
  <script>
  MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
              svg: { fontCache: 'global' } };
  </script>
  <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
  </script>
  <script src="./theme/js/bundle.js"></script>
  <script data-goatcounter="https://jameswhanlon.goatcounter.com/count"
          async src="//gc.zgo.at/count.js"></script>
</head>
<body>
  <header>
  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0 text-uppercase">
          <li class="nav-item">
              <a class="nav-link" href="/index.html">notes</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/projects.html">projects</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/archive.html">archive</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/about.html">about</a>
          </li>
          <li class="nav-item">
              <a class="nav-link" href="/links.html">links</a>
          </li>
        </ul>
        <a class="navbar-brand" href="#">James W. Hanlon</a>
        <button class="btn btn-secondary" type="button" onclick="toggleMode(this)">
          <!-- Initial button state -->
            <i class="bi bi-moon-fill"></i>
        </button>
      </div>
    </div>
  </nav>
  </header>

  <main class="flex-shrink-0">
  <div class="container">
  <h1>
    Querying logical paths in a Verilog&nbsp;design
  </h1>
  <div class="lead">
    <time class="published" datetime="2018-11-20T00:00:00+01:00">
      20 Nov 2018
    </time><br>
      <span class="article-tag small"><a href="/tag/computing.html">computing</a></span>
      <span class="article-tag small"><a href="/tag/microelectronics.html">microelectronics</a></span>
      <span class="article-tag small"><a href="/tag/verilog.html">verilog</a></span>
  </div>
  <div class="article-body">
    <p>I wrote a simple command-line tool for querying logical paths in a Verilog
design. My motivation for doing this is that it&#8217;s easy to create complex logic
in Verilog, particularly between modules, but more difficult to understand
exactly what is driving a particular net, just from inspecting the code. It is
the complex cones of logic that lead to timing problems in a synthesised
design, but having to push a design through a synthesis flow takes time, making
speculative timing fixes a lengthy process. A command-line tool is useful as it
can be integrated into more complex workflows, in contrast with using more
complex and usually graphical <span class="caps">EDA</span>&nbsp;tooling.</p>
<p>The tool addresses high-level structural problems in a design, such as
incorrect dependencies when a signal including logic that is not necessary to
its function. It does not deal with other timing issues that are a product of
the synthesis and physical build of the design. As such, all the structural
information required is contained within the Verilog source&nbsp;code.</p>
<p>This note briefly explains how the tool works and records some ideas on how it
could be&nbsp;extended.</p>
<h2>Use</h2>
<p>Instructions to build the tool are in the <span class="caps">README</span> in the <a href="https://github.com/jameshanlon/netlist-paths/blob/master/README.md">GitHub
repository</a>.
Assuming&nbsp;the <code>netlist-paths</code> install <code>bin</code> directory is available in&nbsp;your
<code>PATH</code>, then using the <a href="https://github.com/cliffordwolf/picorv32">PicoRV32 processor
implementation</a> as an example, its
netlist can be generated as&nbsp;follows:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/cliffordwolf/picorv32.git
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>picorv32
$<span class="w"> </span>verilator<span class="w"> </span>--dump-netlist-graph<span class="w"> </span>-o<span class="w"> </span>netlist.graph<span class="w"> </span>picorv32.v<span class="w"> </span>--top-module<span class="w"> </span>picorv32_axi
...<span class="w"> </span><span class="c1"># lots of warnings</span>
</code></pre></div>

<p>Here a modified version of <a href="https://www.veripool.org/wiki/verilator">Verilator</a>
is used to generate the netlist. (Note&nbsp;that <code>netlist-paths</code> can invoke
Verilator but with&nbsp;the <code>--compile</code> option, but PicoRV32 requires&nbsp;Verilator&#8217;s
<code>--top-module</code> option. It may be useful to extend the command line arguments to
allow arbitrary arguments to be passed to Verilator.) Verilator performs the
generation by traversing the abstract syntax tree of the design and constructs
a graph of dependencies between variables and combinatorial logical constructs,
and identifies variables corresponding to sequential elements (flip&nbsp;flops).</p>
<p>The graph structure/netlist is written to file in <a href="https://graphviz.gitlab.io/_pages/doc/info/lang.html">Graphviz dot
format</a>, and specifies
the vertices, with their type and source code location information, and the
edges between them. The analysis tool reads this file and reports on the
connectivity between&nbsp;points.</p>
<div class="highlight"><pre><span></span><code><span class="nx">digraph</span><span class="w"> </span><span class="nx">netlist</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">n0</span><span class="p">[</span><span class="nx">id</span><span class="p">=</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">=</span><span class="s">&quot;ASSIGNW&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">=</span><span class="s">&quot;picorv32.v:2539&quot;</span><span class="p">];</span>
<span class="w">  </span><span class="nx">n1</span><span class="p">[</span><span class="nx">id</span><span class="p">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">=</span><span class="s">&quot;PORT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">dir</span><span class="p">=</span><span class="s">&quot;OUTPUT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">=</span><span class="s">&quot;picorv32_axi.trace_data&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">=</span><span class="s">&quot;picorv32.v:2539&quot;</span><span class="p">];</span>
<span class="w">  </span><span class="nx">n2</span><span class="p">[</span><span class="nx">id</span><span class="p">=</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">=</span><span class="s">&quot;PORT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">dir</span><span class="p">=</span><span class="s">&quot;OUTPUT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">=</span><span class="s">&quot;trace_data&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">=</span><span class="s">&quot;picorv32.v:2539&quot;</span><span class="p">];</span>
<span class="w">  </span><span class="nx">n3</span><span class="p">[</span><span class="nx">id</span><span class="p">=</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">=</span><span class="s">&quot;ASSIGNW&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">=</span><span class="s">&quot;picorv32.v:2538&quot;</span><span class="p">];</span>
<span class="w">  </span><span class="nx">n4</span><span class="p">[</span><span class="nx">id</span><span class="p">=</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">=</span><span class="s">&quot;PORT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">dir</span><span class="p">=</span><span class="s">&quot;OUTPUT&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">=</span><span class="s">&quot;picorv32_axi.trace_valid&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">loc</span><span class="p">=</span><span class="s">&quot;picorv32.v:2538&quot;</span><span class="p">];</span>
<span class="w">  </span><span class="o">...</span>
<span class="w">  </span><span class="nx">n0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n2</span><span class="p">;</span>
<span class="w">  </span><span class="nx">n1</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n0</span><span class="p">;</span>
<span class="w">  </span><span class="nx">n3</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n5</span><span class="p">;</span>
<span class="w">  </span><span class="nx">n4</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n3</span><span class="p">;</span>
<span class="w">  </span><span class="nx">n6</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nx">n8</span><span class="p">;</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</code></pre></div>

<p>A vertex in this netlist corresponds to the occurrence of a variable (ie a
symbolic name). A given symbolic name can appear in different vertices,
corresponding to its different uses. To see this, the&nbsp;option <code>--dumpnames</code>
prints the names, types and directions of all the vertices in the graph. This
output can be piped&nbsp;through <code>grep</code> to locate particular signals. For example,
to see all the output&nbsp;variables:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>netlist-paths<span class="w"> </span>netlist.graph<span class="w"> </span>--dumpnames<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>OUTPUT
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>eoi
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_araddr
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_arprot
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_arvalid
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_awaddr
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_awprot
PORT<span class="w"> </span>OUTPUT<span class="w"> </span>mem_axi_awvalid
...
</code></pre></div>

<p>Or all the&nbsp;registers:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>netlist-paths<span class="w"> </span>netlist.graph<span class="w"> </span>--dumpnames<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>REG_DST
REG_DST<span class="w"> </span>picorv32_axi.axi_adapter.ack_arvalid
REG_DST<span class="w"> </span>picorv32_axi.axi_adapter.ack_awvalid
REG_DST<span class="w"> </span>picorv32_axi.axi_adapter.ack_wvalid
REG_DST<span class="w"> </span>picorv32_axi.axi_adapter.xfer_done
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.alu_out_0_q
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.alu_out_q
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.alu_wait
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.alu_wait_2
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.cached_ascii_instr
REG_DST<span class="w"> </span>picorv32_axi.picorv32_core.cached_insn_imm
...
</code></pre></div>

<p>Here,&nbsp;the <code>REG_DST</code> type corresponds to a variable that is the left-hand side
of a non-blocking&nbsp;assignment <code>&lt;=</code>. Conversely,&nbsp;the <code>REG_SRC</code> type is where the
same variable appears in an expression on the right-hand side. In general,
there can only be a&nbsp;single <code>REG_DST</code> node with a specific name, whereas there
can be&nbsp;multiple <code>REG_SRC</code> nodes with a specific names. The same is true&nbsp;with
<code>VAR</code>, <code>WIRE</code> and <code>PORT</code> types. When using this tool, I&#8217;ve found it
straight forward to locate the variables I need&nbsp;using <code>grep</code> with
<code>--dumpnames</code>, but there may be more sophisticated approaches that could be&nbsp;implemented.</p>
<p>A start or end point can be specified as any named vertex, which is anything
except logic statements. You can query if a path exists between two&nbsp;points:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>netlist-paths<span class="w"> </span>netlist.graph<span class="w"> </span>--start<span class="w"> </span>picorv32_axi.picorv32_core.cpu_state<span class="w"> </span>--end<span class="w"> </span>picorv32_axi.picorv32_core.dbg_valid_insn
<span class="w">  </span>picorv32_axi.picorv32_core.cpu_state<span class="w">        </span>REG_SRC<span class="w">         </span>picorv32.v:1160
<span class="w">  </span>ASSIGNW<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:1373
<span class="w">  </span>picorv32_axi.picorv32_core.launch_next_insn<span class="w"> </span>WIRE<span class="w">            </span>picorv32.v:750
<span class="w">  </span>ALWAYS<span class="w">                                      </span>LOGIC<span class="w">           </span>picorv32.v:760
<span class="w">  </span>picorv32_axi.picorv32_core.dbg_valid_insn<span class="w">   </span>REG_DST<span class="w">         </span>picorv32.v:751
</code></pre></div>

<p>In this path report, it lists the sequential dependencies from the start point
to the end point, through a sequence of zero or more combinatorial logic
statements/blocks, with each dependency corresponding to a variable.
Importantly, the filenames and line numbers given reference the original source&nbsp;code.</p>
<p>Since there may be multiple vertices with a name matching the specified start
and end points, the register version is preferentially located&nbsp;(<code>SRC</code> for a
start point&nbsp;and <code>DST</code> for an end point), followed&nbsp;by <code>VAR</code>, <code>WIRE</code> and
<code>PORT</code> types.</p>
<p>You can also query all the paths that fan out from a particular start&nbsp;point:</p>
<div class="highlight"><pre><span></span><code>netlist-paths netlist.graph --start picorv32_axi.picorv32_core.cpu_state
Path 1
  picorv32_axi.picorv32_core.cpu_state        REG_SRC         picorv32.v:1160
  ASSIGNW                                     LOGIC           picorv32.v:1373
  picorv32_axi.picorv32_core.launch_next_insn WIRE            picorv32.v:750
  ALWAYS                                      LOGIC           picorv32.v:760
  picorv32_axi.picorv32_core.q_ascii_instr    REG_DST         picorv32.v:742

Path 2
  picorv32_axi.picorv32_core.cpu_state        REG_SRC         picorv32.v:1160
  ASSIGNW                                     LOGIC           picorv32.v:1373
  picorv32_axi.picorv32_core.launch_next_insn WIRE            picorv32.v:750
  ALWAYS                                      LOGIC           picorv32.v:760
  picorv32_axi.picorv32_core.q_insn_imm       REG_DST         picorv32.v:743

Path 3
  picorv32_axi.picorv32_core.cpu_state        REG_SRC         picorv32.v:1160
  ASSIGNW                                     LOGIC           picorv32.v:1373
  picorv32_axi.picorv32_core.launch_next_insn WIRE            picorv32.v:750
  ALWAYS                                      LOGIC           picorv32.v:760
  picorv32_axi.picorv32_core.q_insn_opcode    REG_DST         picorv32.v:744
...
Found 223 path(s)
</code></pre></div>

<p>Or query all the paths that fan in to a particular end&nbsp;point:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>netlist-paths<span class="w"> </span>netlist.graph<span class="w"> </span>--end<span class="w"> </span>picorv32_axi.picorv32_core.dbg_valid_insn
Path<span class="w"> </span><span class="m">1</span>
<span class="w">  </span>picorv32_axi.picorv32_core.trap<span class="w">           </span>REG_SRC<span class="w">         </span>picorv32.v:86
<span class="w">  </span>ALWAYS<span class="w">                                    </span>LOGIC<span class="w">           </span>picorv32.v:760
<span class="w">  </span>picorv32_axi.picorv32_core.dbg_valid_insn<span class="w"> </span>REG_DST<span class="w">         </span>picorv32.v:751

Path<span class="w"> </span><span class="m">2</span>
<span class="w">  </span>picorv32_axi.picorv32_core.instr_lui<span class="w">       </span>REG_SRC<span class="w">         </span>picorv32.v:630
<span class="w">  </span>ALWAYS<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:684
<span class="w">  </span>ASSIGN<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:685
<span class="w">  </span>picorv32_axi.picorv32_core.new_ascii_instr<span class="w"> </span>VAR<span class="w">             </span>picorv32.v:673
<span class="w">  </span>ALWAYS<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:760
<span class="w">  </span>picorv32_axi.picorv32_core.dbg_valid_insn<span class="w">  </span>REG_DST<span class="w">         </span>picorv32.v:751

Path<span class="w"> </span><span class="m">3</span>
<span class="w">  </span>picorv32_axi.picorv32_core.instr_auipc<span class="w">     </span>REG_SRC<span class="w">         </span>picorv32.v:630
<span class="w">  </span>ALWAYS<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:684
<span class="w">  </span>ASSIGN<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:685
<span class="w">  </span>picorv32_axi.picorv32_core.new_ascii_instr<span class="w"> </span>VAR<span class="w">             </span>picorv32.v:673
<span class="w">  </span>ALWAYS<span class="w">                                     </span>LOGIC<span class="w">           </span>picorv32.v:760
<span class="w">  </span>picorv32_axi.picorv32_core.dbg_valid_insn<span class="w">  </span>REG_DST<span class="w">         </span>picorv32.v:751
...
Found<span class="w"> </span><span class="m">74</span><span class="w"> </span>paths
</code></pre></div>

<p>Since the number of paths between any two points in an arbitrary graph grows
exponentially with the size of the graph, it infeasible to report all paths
between two points, so this tool simply looks for any path that satisfies those
constraints. (An option is provided to enumerate all paths, but it can only be
used on small&nbsp;netlists.)</p>
<p>When trying to match a particular path in a physical build it it useful to
further constrain the search to force it to match the same path. This can be
done by specifying through points with&nbsp;the <code>--through</code> option. Each through
argument is taken in order as an intermediate point in the path. The same
search algorithm is used on each pair of points to build up a composite report.
For&nbsp;example:</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>netlist-paths<span class="w"> </span>netlist.graph<span class="w"> </span>--start<span class="w"> </span>picorv32_axi.axi_adapter.ack_wvalid<span class="w"> </span>--through<span class="w"> </span>picorv32_axi.axi_adapter.mem_axi_wvalid<span class="w"> </span>--end<span class="w"> </span>mem_axi_wvalid
<span class="w">  </span>picorv32_axi.axi_adapter.ack_wvalid<span class="w">     </span>REG_SRC<span class="w">         </span>picorv32.v:2700
<span class="w">  </span>ASSIGNW<span class="w">                                 </span>LOGIC<span class="w">           </span>picorv32.v:2711
<span class="w">  </span>picorv32_axi.axi_adapter.mem_axi_wvalid<span class="w"> </span>PORT<span class="w">            </span>picorv32.v:2671
<span class="w">  </span>ASSIGNW<span class="w">                                 </span>LOGIC<span class="w">           </span>picorv32.v:2556
<span class="w">  </span>picorv32_axi.mem_axi_wvalid<span class="w">             </span>PORT<span class="w">            </span>picorv32.v:2484
<span class="w">  </span>ASSIGNW<span class="w">                                 </span>LOGIC<span class="w">           </span>picorv32.v:2484
<span class="w">  </span>mem_axi_wvalid<span class="w">                          </span>PORT<span class="w">            </span>picorv32.v:2484
</code></pre></div>

<h2>Implementation</h2>
<p>To avoid writing a preprocessor and parser for Verilog, I modified
<a href="https://www.veripool.org/wiki/verilator">Verilator</a> to obtain the netlist of a
Verilog design. (I would have liked to use
<a href="http://www.clifford.at/yosys/">Yosys</a> to do this because it provides a neat
interface to adding custom <span class="caps">AST</span> passes, but unfortunately it does not currently
support enough of the SystemVerilog standard.) The Verilator modifications add
a new <span class="caps">AST</span> visitor, which walks the tree after it has been processed, for
example to propagate constants and inline tasks and&nbsp;modules.</p>
<p>The <code>netlist-paths</code> tool is implemented in C++ and makes use of the Boost Graph
Library. Paths are identified using&nbsp;the <code>boost::depth_first_search</code> algorithm.
The all-fan-out report enumerates paths to all the end points in a depth-first
traversal of the graph, the fan-in variant uses&nbsp;the <code>boost::reverse_graph</code>
adaptor and performs the same algorithm. Properties are associated with
vertices in the graph using&nbsp;a <code>boost::dynamic_property_map</code>. I put together a
<a href="https://github.com/jameshanlon/boost_graph_example">simple example program</a> to
illustrate how to use these maps (plus some other library features) since I
found there were some subtleties in getting this to&nbsp;work.</p>
<h2>Improvements</h2>
<p>There are many ways this tool could be extended and improved. Here are a few&nbsp;ideas:</p>
<ul>
<li>Provide additional flexibility to allow a choice between multiple matching start, through or end&nbsp;points.</li>
<li>Provide a mechanism to search for high fan-out&nbsp;variables.</li>
<li>Provide a mechanism to seach for the longest paths in the&nbsp;graph.</li>
<li>Provide a mechanism to assert there is no logical path between two sub&nbsp;modules.</li>
<li>Detect and report timing&nbsp;loops.</li>
<li>Add options&nbsp;to <code>dumpnames</code> to filter by type or&nbsp;direction.</li>
<li>Add options to the querys to select only internal paths or only input/output&nbsp;paths.</li>
</ul>
<h2>Links</h2>
<ul>
<li><a href="https://github.com/jameshanlon/netlist-paths">Netlist paths tool on&nbsp;GitHub</a></li>
<li><a href="https://github.com/jameshanlon/verilator">Modified Verilator on&nbsp;GitHub</a></li>
<li><a href="https://github.com/jameshanlon/boost_graph_example">Boost Graph Library&nbsp;example</a></li>
</ul>
  </div>
  <div class="article-footer">
    <p>Please get in touch (mail @ this domain) with any
    comments, corrections or suggestions.</p>
  </div>
  </div>
  </main>

  <hr>
  <footer class="text-muted">
    <div class="container">
      <div class="small">
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          <img alt="Creative Commons Licence" style="border-width:0"
               src="https://i.creativecommons.org/l/by/4.0/80x15.png" />
        </a>
        <br>
        Unless otherwise noted, all content is freely available under a
        <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
          Creative Commons Attribution 4.0 International License</a>.<br>
        The views expressed on this website are the authorâs personal views and should not be
        attributed to any other person, including that of their employer.<br>
        <br>
        Subscribe: <a href="https://jameswhanlon.com/reeds/atom.xml">Atom</a> /
        <a href="https://jameswhanlon.com/reeds/rss.xml">RSS</a>
      </div>
    </div>
  </footer>
  <script>
    function toggleMode(x) {
      // Toggle the colour mode in Bootstrap.
      if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
        document.documentElement.setAttribute('data-bs-theme','light')
      }
      else {
        document.documentElement.setAttribute('data-bs-theme','dark')
      }
      // Toggle the light/dark icon.
      x.firstElementChild.classList.toggle('bi-brightness-high-fill');
      x.firstElementChild.classList.toggle('bi-moon-fill');
      // Toggle the Pygments style.
      var elem = document.getElementById('pygments-style');
      if (elem.getAttribute('href') == './theme/css/pygments-dark.css') {
        elem.setAttribute('href', './theme/css/pygments.css');
      } else {
        elem.setAttribute('href', './theme/css/pygments-dark.css');
      }
    }
  </script>
</body>
</html>